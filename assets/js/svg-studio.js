// è¯­è¨€æ•°æ®ç»“æ„
const i18nData = {
    'zh-CN': {
        // é¡µé¢æ ‡é¢˜å’Œæè¿°
        title: 'SVG Studio Pro - SVG æŸ¥çœ‹å™¨å’Œå¯¼å‡ºå·¥å…·',
        description: 'ä¸“ä¸šçš„SVGæŸ¥çœ‹å™¨å’Œå¯¼å‡ºå·¥å…·ï¼Œæ”¯æŒå®æ—¶é¢„è§ˆã€å¤šæ ¼å¼å¯¼å‡º(PNG/ICO/WebP/JPG)ã€æ‰¹é‡å¤„ç†ã€Chromeå›¾æ ‡åŒ…ç”Ÿæˆã€‚ç®€æ´é«˜æ•ˆï¼Œå®Œå…¨å…è´¹ã€‚',
        keywords: 'SVGæŸ¥çœ‹å™¨,SVGç¼–è¾‘å™¨,SVGè½¬PNG,SVGè½¬ICO,å›¾æ ‡åˆ¶ä½œ,çŸ¢é‡å›¾å½¢,åœ¨çº¿å·¥å…·,å…è´¹å·¥å…·,Chromeå›¾æ ‡,æ‰¹é‡å¯¼å‡º',
        ogTitle: 'SVG Studio Pro - ä¸“ä¸šSVGæŸ¥çœ‹å™¨å’Œå¯¼å‡ºå·¥å…·',
        ogDescription: 'åŠŸèƒ½å¼ºå¤§çš„SVGå¤„ç†å·¥å…·ï¼Œæ”¯æŒå®æ—¶é¢„è§ˆã€å¤šæ ¼å¼å¯¼å‡ºã€æ‰¹é‡å¤„ç†ã€‚å®Œå…¨å…è´¹ï¼Œæ— éœ€æ³¨å†Œã€‚',
        twitterTitle: 'SVG Studio Pro - ä¸“ä¸šSVGæŸ¥çœ‹å™¨å’Œå¯¼å‡ºå·¥å…·',
        twitterDescription: 'åŠŸèƒ½å¼ºå¤§çš„SVGå¤„ç†å·¥å…·ï¼Œæ”¯æŒå®æ—¶é¢„è§ˆã€å¤šæ ¼å¼å¯¼å‡ºã€æ‰¹é‡å¤„ç†ã€‚å®Œå…¨å…è´¹ï¼Œæ— éœ€æ³¨å†Œã€‚',
        
        // ä¸»è¦ç•Œé¢æ–‡æœ¬
        svgCodeInput: 'SVG ä»£ç è¾“å…¥',
        svgCodeLabel: 'SVG ä»£ç ',
        uploadText: 'æ‹–æ‹½ SVG æ–‡ä»¶åˆ°è¿™é‡Œæˆ–',
        uploadLink: 'ç‚¹å‡»é€‰æ‹©æ–‡ä»¶',
        uploadHint: 'æ”¯æŒ .svg æ ¼å¼æ–‡ä»¶ | æ”¯æŒ Ctrl+V (Mac: Cmd+V) ç²˜è´´æ–‡ä»¶',
        dragDropHint: 'ğŸ’¡ æç¤ºï¼šæ‚¨ä¹Ÿå¯ä»¥ç›´æ¥å°† SVG æ–‡ä»¶æ‹–æ‹½åˆ°é¡µé¢ä»»æ„ä½ç½®è¿›è¡Œå¯¼å…¥',
        placeholder: 'åœ¨è¿™é‡Œç²˜è´´ä½ çš„ SVG ä»£ç ï¼Œæˆ–ä½¿ç”¨ä¸Šæ–¹çš„æ–‡ä»¶ä¸Šä¼ ...',
        
        
        
        // å°ºå¯¸è®¾ç½®
        widthLabel: 'å®½åº¦ (px)',
        heightLabel: 'é«˜åº¦ (px)',
        batchExportSizes: 'æ‰¹é‡å¯¼å‡ºå°ºå¯¸é€‰æ‹©',
        selectAll: 'å…¨é€‰',
        clearAll: 'æ¸…ç©º',
        selectedSizesCount: 'å·²é€‰æ‹© {count} ä¸ªå°ºå¯¸',
        
        // å¡ç‰‡æ ‡é¢˜
        sizeAndExport: 'å°ºå¯¸è®¾ç½®ä¸å¯¼å‡º',
        batchExport: 'æ‰¹é‡å¯¼å‡º',
        
        // æŒ‰é’®æ–‡æœ¬
        downloadPNG: 'ä¸‹è½½ PNG',
        downloadICO: 'ä¸‹è½½ ICO',
        batchExportPNG: 'æ‰¹é‡å¯¼å‡º PNG',
        batchExportICO: 'æ‰¹é‡å¯¼å‡º ICO',
        exportPNG: 'å¯¼å‡º PNG',
        exportICO: 'å¯¼å‡º ICO',
        chromeIconPack: 'Chrome å›¾æ ‡åŒ…',
        preview: 'é¢„è§ˆ',
        exportAllPacks: 'ä¸€é”®å¯¼å‡ºå…¨è§„æ ¼',
        exportWeb: 'Web',
        exportChrome: 'Chrome æ‰©å±•',
        exportAndroid: 'Android',
        exportIOS: 'iOS',
        exportWindows: 'Windows',
        exportMacOS: 'macOS',
        exportSocial: 'Social',
        selectExport: 'é€‰æ‹©å¯¼å‡º',
        confirm: 'ç¡®è®¤',
        cancel: 'å–æ¶ˆ',
        
        // çŠ¶æ€æ–‡æœ¬
        realtimeUpdate: 'å®æ—¶æ›´æ–°',
        waitingInput: 'ç­‰å¾…è¾“å…¥',
        invalidSize: 'å°ºå¯¸æ— æ•ˆ',
        formatError: 'æ ¼å¼é”™è¯¯',
        updated: 'å·²æ›´æ–°',
        generating: 'ç”Ÿæˆä¸­...',
        packing: 'æ‰“åŒ…ä¸­...',
        batchGenerating: 'æ‰¹é‡ç”Ÿæˆä¸­...',
        exportingAll: 'å¯¼å‡ºæ‰€æœ‰è§„æ ¼ä¸­...',
        exportingPack: 'å¯¼å‡ºä¸­...',
        
        // å¯¼èˆªæ 
        'nav-home': 'é¦–é¡µ',
        'nav-tools': 'å·¥å…·',
        'nav-viewer': 'SVG æŸ¥çœ‹å™¨',
        'nav-converter': 'æ ¼å¼è½¬æ¢',
        'nav-batch': 'æ‰¹é‡å¤„ç†',
        'nav-about': 'å…³äº',
        'nav-docs': 'æ–‡æ¡£',
        'nav-start': 'å¼€å§‹ä½¿ç”¨',
        
        // é¢„è§ˆåŒºåŸŸ
        previewPlaceholder: 'åœ¨å·¦ä¾§è¾“å…¥ SVG ä»£ç ï¼Œé¢„è§ˆå°†è‡ªåŠ¨æ›´æ–°',
        updatingPreview: 'æ­£åœ¨æ›´æ–°é¢„è§ˆ...',
        inputting: 'æ­£åœ¨è¾“å…¥...',
        presetSizes: 'é¢„è®¾å°ºå¯¸',
        
        // é”™è¯¯å’ŒæˆåŠŸæ¶ˆæ¯
        errorEnterSVG: 'è¯·è¾“å…¥ SVG ä»£ç ',
        errorValidSize: 'è¯·è¾“å…¥æœ‰æ•ˆçš„å®½åº¦å’Œé«˜åº¦',
        errorSVGFormat: 'SVG ä»£ç æ ¼å¼é”™è¯¯',
        errorInvalidSVG: 'SVG ä»£ç æ— æ•ˆ',
        errorEnterSVGFirst: 'è¯·å…ˆè¾“å…¥ SVG ä»£ç ',
        errorSelectSize: 'è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå¯¼å‡ºå°ºå¯¸',
        errorValidSVGFile: 'è¯·é€‰æ‹©æœ‰æ•ˆçš„ SVG æ–‡ä»¶',
        errorFileRead: 'æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•',
        errorDragSVG: 'è¯·æ‹–æ‹½ SVG æ ¼å¼çš„æ–‡ä»¶',

        errorNetworkTimeout: 'ç½‘ç»œè¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥',
        
        successPreviewUpdate: 'é¢„è§ˆæ›´æ–°æˆåŠŸï¼',
        successPNGDownload: 'PNG æ–‡ä»¶å·²ä¸‹è½½ ({size})',
        successFileUpload: 'æ–‡ä»¶ "{name}" ä¸Šä¼ æˆåŠŸï¼',
        successFilePaste: 'å·²ç²˜è´´æ–‡ä»¶: {name}',
        successSVGPaste: 'å·²ç²˜è´´ SVG ä»£ç ',
        successDragUpload: 'å·²æ‹–æ‹½ä¸Šä¼ : {name}',
        successICODownload: 'ICO æ–‡ä»¶ä¸‹è½½æˆåŠŸï¼åŒ…å« 16x16ã€32x32ã€48x48ã€256x256 å››ç§å°ºå¯¸',
        successChromePackDownload: 'Chrome å›¾æ ‡åŒ…å·²ä¸‹è½½ (icons.zip)',
        successBatchExport: 'æ‰¹é‡å¯¼å‡ºæˆåŠŸï¼å·²ç”Ÿæˆ {count} ä¸ªå°ºå¯¸çš„PNGæ–‡ä»¶',
        successAllExport: 'æ‰€æœ‰è§„æ ¼å·²æ‰“åŒ…ä¸‹è½½ï¼ˆall-assets.zipï¼‰',
        successPackExport: 'æ‰“åŒ…å®Œæˆ',
        
        // ç²˜è´´æç¤ºï¼ˆæ¢å¤ï¼‰
        pasteReady: 'å‡†å¤‡ç²˜è´´ SVG æ–‡ä»¶...',
        pasteFileOrCode: 'ç²˜è´´ SVG æ–‡ä»¶æˆ–ä»£ç ...',
        pastePrompt: 'è¯·ç²˜è´´ SVG æ–‡ä»¶æˆ–ä»£ç ',
        
        // README æ¨¡æ¿
        readmeWeb: 'æ­¤åŒ…åŒ…å« Web æ‰€éœ€å›¾æ ‡ï¼ˆfaviconã€apple touchã€PWAï¼‰ã€‚',
        readmeChrome: 'æ­¤åŒ…åŒ…å« Chrome æ‰©å±•æ‰€éœ€å›¾æ ‡å°ºå¯¸ã€‚',
        readmeAndroid: 'æ­¤åŒ…åŒ…å« Android æ‰€éœ€ mipmap/play store/adaptive å‰æ™¯å›¾æ ‡ã€‚',
        readmeIOS: 'æ­¤åŒ…åŒ…å« iOS æ‰€éœ€ iPhone/iPad/App Store å›¾æ ‡ã€‚',
        readmeWindows: 'æ­¤åŒ…åŒ…å« Windows æ‰€éœ€å¤šå°ºå¯¸ ICOã€‚',
        readmeMacOS: 'æ­¤åŒ…åŒ…å« macOS å¤šå°ºå¯¸ PNGï¼Œå¯ç”¨ iconutil ç”Ÿæˆ ICNSã€‚',
        readmeSocial: 'æ­¤åŒ…åŒ…å«ç¤¾äº¤å¤´åƒä¸åˆ†äº«å›¾ï¼ˆå« 1200x630ï¼‰ã€‚',
        readmeFilename: 'ç›®å½•è¯´æ˜.txt',

        manifestTitle: 'å¯¼å‡ºæ–‡ä»¶æ¸…å•',
        manifestFile: 'manifest.txt',
        manifestGenerated: 'æ¸…å•ç”Ÿæˆäº',
        successLangSwitch: 'è¯­è¨€å·²åˆ‡æ¢ä¸º: {langName}',
    },
    'zh-TW': {
        // SEO å’Œé¡µé¢å…ƒæ•°æ®
        title: 'SVG Studio Pro - SVG æª¢è¦–å™¨å’ŒåŒ¯å‡ºå·¥å…·',
        description: 'å°ˆæ¥­çš„SVGæª¢è¦–å™¨å’ŒåŒ¯å‡ºå·¥å…·ï¼Œæ”¯æ´å³æ™‚é è¦½ã€å¤šæ ¼å¼åŒ¯å‡º(PNG/ICO/WebP/JPG)ã€æ‰¹æ¬¡è™•ç†ã€Chromeåœ–ç¤ºåŒ…ç”Ÿæˆã€‚ç°¡æ½”é«˜æ•ˆï¼Œå®Œå…¨å…è²»ã€‚',
        keywords: 'SVGæª¢è¦–å™¨,SVGç·¨è¼¯å™¨,SVGè½‰PNG,SVGè½‰ICO,åœ–ç¤ºè£½ä½œ,å‘é‡åœ–å½¢,ç·šä¸Šå·¥å…·,å…è²»å·¥å…·,Chromeåœ–ç¤º,æ‰¹æ¬¡åŒ¯å‡º',
        ogTitle: 'SVG Studio Pro - å°ˆæ¥­SVGæª¢è¦–å™¨å’ŒåŒ¯å‡ºå·¥å…·',
        ogDescription: 'åŠŸèƒ½å¼·å¤§çš„SVGè™•ç†å·¥å…·ï¼Œæ”¯æ´å³æ™‚é è¦½ã€å¤šæ ¼å¼åŒ¯å‡ºã€æ‰¹æ¬¡è™•ç†ã€‚å®Œå…¨å…è²»ï¼Œç„¡éœ€è¨»å†Šã€‚',
        twitterTitle: 'SVG Studio Pro - å°ˆæ¥­SVGæª¢è¦–å™¨å’ŒåŒ¯å‡ºå·¥å…·',
        twitterDescription: 'åŠŸèƒ½å¼·å¤§çš„SVGè™•ç†å·¥å…·ï¼Œæ”¯æ´å³æ™‚é è¦½ã€å¤šæ ¼å¼åŒ¯å‡ºã€æ‰¹æ¬¡è™•ç†ã€‚å®Œå…¨å…è²»ï¼Œç„¡éœ€è¨»å†Šã€‚',
        
        // ä¸»è¦åŠŸèƒ½å€åŸŸ
        svgCodeInput: 'SVG ç¨‹å¼ç¢¼è¼¸å…¥',
        svgCodeLabel: 'SVG ç¨‹å¼ç¢¼',
        uploadText: 'æ‹–æ‹½ SVG æª”æ¡ˆåˆ°é€™è£¡æˆ–',
        uploadLink: 'é»æ“Šé¸æ“‡æª”æ¡ˆ',
        uploadHint: 'æ”¯æ´ .svg æ ¼å¼æª”æ¡ˆ | æ”¯æ´ Ctrl+V (Mac: Cmd+V) è²¼ä¸Šæª”æ¡ˆ',
        dragDropHint: 'ğŸ’¡ æç¤ºï¼šæ‚¨ä¹Ÿå¯ä»¥ç›´æ¥å°‡ SVG æª”æ¡ˆæ‹–æ‹½åˆ°é é¢ä»»æ„ä½ç½®é€²è¡ŒåŒ¯å…¥',
        placeholder: 'åœ¨é€™è£¡è²¼ä¸Šä½ çš„ SVG ç¨‹å¼ç¢¼ï¼Œæˆ–ä½¿ç”¨ä¸Šæ–¹çš„æª”æ¡ˆä¸Šå‚³...',



        // å°ºå¯¸è¨­å®š
        widthLabel: 'å¯¬åº¦ (px)',
        heightLabel: 'é«˜åº¦ (px)',
        batchExportSizes: 'æ‰¹æ¬¡åŒ¯å‡ºå°ºå¯¸é¸æ“‡',
        selectAll: 'å…¨é¸',
        clearAll: 'æ¸…ç©º',
        selectedSizesCount: 'å·²é¸æ“‡ {count} å€‹å°ºå¯¸',

        // åŠŸèƒ½æŒ‰éˆ•
        sizeAndExport: 'å°ºå¯¸è¨­å®šèˆ‡åŒ¯å‡º',
        batchExport: 'æ‰¹æ¬¡åŒ¯å‡º',

        // ä¸‹è¼‰æŒ‰éˆ•
        downloadPNG: 'ä¸‹è¼‰ PNG',
        downloadICO: 'ä¸‹è¼‰ ICO',
        batchExportPNG: 'æ‰¹æ¬¡åŒ¯å‡º PNG',
        batchExportICO: 'æ‰¹æ¬¡åŒ¯å‡º ICO',
        exportPNG: 'å°å‡º PNG',
        exportICO: 'å°å‡º ICO',
        chromeIconPack: 'Chrome åœ–ç¤ºåŒ…',
        preview: 'é è¦½',
        exportAllPacks: 'ä¸€éµå°å‡ºå…¨è¦æ ¼',
        exportWeb: 'Web',
        exportChrome: 'Chrome æ“´å……',
        exportAndroid: 'Android',
        exportIOS: 'iOS',
        exportWindows: 'Windows',
        exportMacOS: 'macOS',
        exportSocial: 'Social',
        selectExport: 'é¸æ“‡å°å‡º',
        confirm: 'ç¢ºèª',
        cancel: 'å–æ¶ˆ',

        // ç‹€æ…‹è¨Šæ¯
        realtimeUpdate: 'å³æ™‚æ›´æ–°',
        waitingInput: 'ç­‰å¾…è¼¸å…¥',
        invalidSize: 'å°ºå¯¸ç„¡æ•ˆ',
        formatError: 'æ ¼å¼éŒ¯èª¤',
        updated: 'å·²æ›´æ–°',
        generating: 'ç”Ÿæˆä¸­...',
        packing: 'æ‰“åŒ…ä¸­...',
        batchGenerating: 'æ‰¹æ¬¡ç”Ÿæˆä¸­...',
        exportingAll: 'å°å‡ºæ‰€æœ‰è¦æ ¼ä¸­...',
        exportingPack: 'å°å‡ºä¸­...',

        // å°èˆªé¸å–®
        'nav-home': 'é¦–é ',
        'nav-tools': 'å·¥å…·',
        'nav-viewer': 'SVG æª¢è¦–å™¨',
        'nav-converter': 'æ ¼å¼è½‰æ›',
        'nav-batch': 'æ‰¹æ¬¡è™•ç†',
        'nav-about': 'é—œæ–¼',
        'nav-docs': 'æ–‡ä»¶',
        'nav-start': 'é–‹å§‹ä½¿ç”¨',

        // é è¦½å€åŸŸ
        previewPlaceholder: 'åœ¨å·¦å´è¼¸å…¥ SVG ç¨‹å¼ç¢¼ï¼Œé è¦½å°‡è‡ªå‹•æ›´æ–°',
        updatingPreview: 'æ­£åœ¨æ›´æ–°é è¦½...',
        inputting: 'æ­£åœ¨è¼¸å…¥...',
        presetSizes: 'é è¨­å°ºå¯¸',

        // éŒ¯èª¤è¨Šæ¯
        errorEnterSVG: 'è«‹è¼¸å…¥ SVG ç¨‹å¼ç¢¼',
        errorValidSize: 'è«‹è¼¸å…¥æœ‰æ•ˆçš„å¯¬åº¦å’Œé«˜åº¦',
        errorSVGFormat: 'SVG ç¨‹å¼ç¢¼æ ¼å¼éŒ¯èª¤',
        errorInvalidSVG: 'SVG ç¨‹å¼ç¢¼ç„¡æ•ˆ',
        errorEnterSVGFirst: 'è«‹å…ˆè¼¸å…¥ SVG ç¨‹å¼ç¢¼',
        errorSelectSize: 'è«‹è‡³å°‘é¸æ“‡ä¸€å€‹åŒ¯å‡ºå°ºå¯¸',
        errorValidSVGFile: 'è«‹é¸æ“‡æœ‰æ•ˆçš„ SVG æª”æ¡ˆ',
        errorFileRead: 'æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦',
        errorDragSVG: 'è«‹æ‹–æ‹½ SVG æ ¼å¼çš„æª”æ¡ˆ',

        errorNetworkTimeout: 'ç¶²è·¯è«‹æ±‚é€¾æ™‚ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·š',

        // æˆåŠŸè¨Šæ¯
        successPreviewUpdate: 'é è¦½æ›´æ–°æˆåŠŸï¼',
        successPNGDownload: 'PNG æª”æ¡ˆå·²ä¸‹è¼‰ ({size})',
        successFileUpload: 'æª”æ¡ˆ "{name}" ä¸Šå‚³æˆåŠŸï¼',
        successFilePaste: 'å·²è²¼ä¸Šæª”æ¡ˆ: {name}',
        successSVGPaste: 'å·²è²¼ä¸Š SVG ç¨‹å¼ç¢¼',
        successDragUpload: 'å·²æ‹–æ‹½ä¸Šå‚³: {name}',
        successICODownload: 'ICO æª”æ¡ˆä¸‹è¼‰æˆåŠŸï¼åŒ…å« 16x16ã€32x32ã€48x48ã€256x256 å››ç¨®å°ºå¯¸',
        successChromePackDownload: 'Chrome åœ–ç¤ºåŒ…å·²ä¸‹è¼‰ (icons.zip)',
        successBatchExport: 'æ‰¹æ¬¡åŒ¯å‡ºæˆåŠŸï¼å·²ç”Ÿæˆ {count} å€‹å°ºå¯¸çš„PNGæª”æ¡ˆ',
        successAllExport: 'æ‰€æœ‰è¦æ ¼å·²æ‰“åŒ…ä¸‹è¼‰ï¼ˆall-assets.zipï¼‰',
        successPackExport: 'æ‰“åŒ…å®Œæˆ',
        
        // è²¼ä¸ŠåŠŸèƒ½ï¼ˆæ¢å¾©ï¼‰
        pasteReady: 'æº–å‚™è²¼ä¸Š SVG æª”æ¡ˆ...',
        pasteFileOrCode: 'è²¼ä¸Š SVG æª”æ¡ˆæˆ–ç¨‹å¼ç¢¼...',
        pastePrompt: 'è«‹è²¼ä¸Š SVG æª”æ¡ˆæˆ–ç¨‹å¼ç¢¼',
        
        // README æ¨¡æ¿
        readmeWeb: 'æ­¤åŒ…åŒ…å« Web æ‰€éœ€åœ–ç¤ºï¼ˆfaviconã€apple touchã€PWAï¼‰ã€‚',
        readmeChrome: 'æ­¤åŒ…åŒ…å« Chrome æ“´å……æ‰€éœ€åœ–ç¤ºå°ºå¯¸ã€‚',
        readmeAndroid: 'æ­¤åŒ…åŒ…å« Android æ‰€éœ€ mipmap/play store/adaptive å‰æ™¯åœ–ç¤ºã€‚',
        readmeIOS: 'æ­¤åŒ…åŒ…å« iOS æ‰€éœ€ iPhone/iPad/App Store åœ–ç¤ºã€‚',
        readmeWindows: 'æ­¤åŒ…åŒ…å« Windows æ‰€éœ€å¤šå°ºå¯¸ ICOã€‚',
        readmeMacOS: 'æ­¤åŒ…åŒ…å« macOS å¤šå°ºå¯¸ PNGï¼Œå¯ç”¨ iconutil ç”Ÿæˆ ICNSã€‚',
        readmeSocial: 'æ­¤åŒ…åŒ…å«ç¤¾ç¾¤é ­åƒèˆ‡åˆ†äº«åœ–ï¼ˆå« 1200x630ï¼‰ã€‚',
        readmeFilename: 'ç›®éŒ„èªªæ˜.txt',

        manifestTitle: 'åŒ¯å‡ºæª”æ¡ˆæ¸…å–®',
        manifestFile: 'manifest.txt',
        manifestGenerated: 'æ¸…å–®ç”¢ç”Ÿæ–¼',
        successLangSwitch: 'èªè¨€å·²åˆ‡æ›ç‚º: {langName}',
    },
    'en': {
        // Page title and description
        title: 'SVG Studio Pro - SVG Viewer and Export Tool',
        description: 'Professional SVG viewer and export tool with real-time preview, multi-format export (PNG/ICO/WebP/JPG), batch processing, and Chrome icon pack generation. Simple, efficient, and completely free.',
        keywords: 'SVG viewer,SVG editor,SVG to PNG,SVG to ICO,icon maker,vector graphics,online tool,free tool,Chrome icons,batch export',
        ogTitle: 'SVG Studio Pro - Professional SVG Viewer and Export Tool',
        ogDescription: 'Powerful SVG processing tool with real-time preview, multi-format export, and batch processing. Completely free, no registration required.',
        twitterTitle: 'SVG Studio Pro - Professional SVG Viewer and Export Tool',
        twitterDescription: 'Powerful SVG processing tool with real-time preview, multi-format export, and batch processing. Completely free, no registration required.',
        
        // Main interface text
        svgCodeInput: 'SVG Code Input',
        svgCodeLabel: 'SVG Code',
        uploadText: 'Drag SVG files here or',
        uploadLink: 'click to select files',
        uploadHint: 'Supports .svg format files | Supports Ctrl+V (Mac: Cmd+V) paste files',
        dragDropHint: 'ğŸ’¡ Tip: You can also drag and drop SVG files anywhere on the page to import',
        placeholder: 'Paste your SVG code here, or use the file upload above...',
        
        
        
        // Size settings
        widthLabel: 'Width (px)',
        heightLabel: 'Height (px)',
        batchExportSizes: 'Batch Export Size Selection',
        selectAll: 'Select All',
        clearAll: 'Clear All',
        selectedSizesCount: '{count} sizes selected',
        
        // Card titles
        sizeAndExport: 'Size Settings & Export',
        batchExport: 'Batch Export',
        
        // Button text
        downloadPNG: 'Download PNG',
        downloadICO: 'Download ICO',
        batchExportPNG: 'Batch Export PNG',
        batchExportICO: 'Batch Export ICO',
        exportPNG: 'Export PNG',
        exportICO: 'Export ICO',
        chromeIconPack: 'Chrome Icon Pack',
        preview: 'Preview',
        exportAllPacks: 'Export All Packs',
        exportWeb: 'Web',
        exportChrome: 'Chrome Extension',
        exportAndroid: 'Android',
        exportIOS: 'iOS',
        exportWindows: 'Windows',
        exportMacOS: 'macOS',
        exportSocial: 'Social',
        selectExport: 'Select Export',
        confirm: 'Confirm',
        cancel: 'Cancel',
        
        // Status text
        realtimeUpdate: 'Real-time update',
        waitingInput: 'Waiting for input',
        invalidSize: 'Invalid size',
        formatError: 'Format error',
        updated: 'Updated',
        generating: 'Generating...',
        packing: 'Packing...',
        batchGenerating: 'Batch generating...',
        exportingAll: 'Exporting all packs...',
        exportingPack: 'Exporting...',
        
        // Navigation
        'nav-home': 'Home',
        'nav-tools': 'Tools',
        'nav-viewer': 'SVG Viewer',
        'nav-converter': 'Format Converter',
        'nav-batch': 'Batch Processing',
        'nav-about': 'About',
        'nav-docs': 'Documentation',
        'nav-start': 'Get Started',
        
        // é¢„è§ˆåŒºåŸŸ
        previewPlaceholder: 'Enter SVG code on the left, preview will update automatically',
        updatingPreview: 'Updating preview...',
        inputting: 'Inputting...',
        presetSizes: 'Preset Sizes',
        
        // Error and success messages
        errorEnterSVG: 'Please enter SVG code',
        errorValidSize: 'Please enter valid width and height',
        errorSVGFormat: 'SVG code format error',
        errorInvalidSVG: 'Invalid SVG code',
        errorEnterSVGFirst: 'Please enter SVG code first',
        errorSelectSize: 'Please select at least one export size',
        errorValidSVGFile: 'Please select a valid SVG file',
        errorFileRead: 'File reading failed, please try again',
        errorDragSVG: 'Please drag SVG format files',

        errorNetworkTimeout: 'Network request timeout, please check your connection',
        
        successPreviewUpdate: 'Preview updated successfully!',
        successPNGDownload: 'PNG file downloaded ({size})',
        successFileUpload: 'File "{name}" uploaded successfully!',
        successFilePaste: 'File pasted: {name}',
        successSVGPaste: 'SVG code pasted',
        successDragUpload: 'Drag uploaded: {name}',
        successICODownload: 'ICO file downloaded successfully! Contains 16x16, 32x32, 48x48, 256x256 sizes',
        successChromePackDownload: 'Chrome icon pack downloaded (icons.zip)',
        successBatchExport: 'Batch export successful! Generated {count} PNG files in different sizes',
        successAllExport: 'All assets packaged (all-assets.zip)',
        successPackExport: 'Packaged',
        
        // Paste prompts (restore)
        pasteReady: 'Ready to paste SVG file...',
        pasteFileOrCode: 'Paste SVG file or code...',
        pastePrompt: 'Please paste SVG file or code',
        
        // README æ¨¡æ¿
        readmeWeb: 'This pack includes Web icons (favicon, apple touch, PWA).',
        readmeChrome: 'This pack includes Chrome extension icon sizes.',
        readmeAndroid: 'This pack includes Android mipmap/play store/adaptive foreground icons.',
        readmeIOS: 'This pack includes iOS iPhone/iPad/App Store icons.',
        readmeWindows: 'This pack includes Windows multi-size ICO.',
        readmeMacOS: 'This pack includes macOS PNG set; use iconutil to produce ICNS.',
        readmeSocial: 'This pack includes social avatar and share images (with 1200x630).',
        readmeFilename: 'README.txt',

        manifestTitle: 'Exported Files Manifest',
        manifestFile: 'manifest.txt',
        manifestGenerated: 'Manifest generated on',
        successLangSwitch: 'Language switched to: {langName}',
    }
};

// å½“å‰è¯­è¨€
let currentLanguage = 'zh-CN';

// è·å–æ–‡æœ¬çš„å‡½æ•°
function getText(key, params = {}) {
    let text = i18nData[currentLanguage][key] || i18nData['zh-CN'][key] || key;
    
    // æ›¿æ¢å‚æ•°
    Object.keys(params).forEach(param => {
        text = text.replace(new RegExp(`\\{${param}\\}`, 'g'), params[param]);
    });
    
    return text;
}

// æ£€æµ‹æµè§ˆå™¨è¯­è¨€
function detectBrowserLanguage() {
    const browserLang = navigator.language || navigator.userLanguage;
    if (browserLang.startsWith('en')) {
        return 'en';
    } else if (browserLang === 'zh-TW' || browserLang === 'zh-HK' || browserLang === 'zh-Hant') {
        return 'zh-TW';
    } else if (browserLang.startsWith('zh')) {
        return 'zh-CN';
    }
    return 'zh-CN'; // é»˜è®¤ç®€ä½“ä¸­æ–‡
}

// åˆ‡æ¢è¯­è¨€
function switchLanguage(lang) {
    currentLanguage = lang;
    localStorage.setItem('svgstudio_language', lang);
    updateAllTexts();
    updatePageTitle();
    
    // æ›´æ–°è¯­è¨€é€‰æ‹©å™¨æ˜¾ç¤º
    updateLanguageDisplay();
}

// æ›´æ–°é¡µé¢æ ‡é¢˜
function updatePageTitle() {
    document.title = getText('title');
    document.documentElement.lang = currentLanguage;
    
    // æ›´æ–°SEO metaæ ‡ç­¾
    updateMetaTag('name', 'description', getText('description'));
    updateMetaTag('name', 'keywords', getText('keywords'));
    updateMetaTag('property', 'og:title', getText('ogTitle'));
    updateMetaTag('property', 'og:description', getText('ogDescription'));
    updateMetaTag('name', 'twitter:title', getText('twitterTitle'));
    updateMetaTag('name', 'twitter:description', getText('twitterDescription'));
}

// è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°metaæ ‡ç­¾
function updateMetaTag(attribute, name, content) {
    let meta = document.querySelector(`meta[${attribute}="${name}"]`);
    if (meta) {
        meta.setAttribute('content', content);
    }
}

// æ›´æ–°æ‰€æœ‰UIæ–‡æœ¬
function updateAllTexts() {
    // æ›´æ–°æ‰€æœ‰å¸¦æœ‰data-i18nå±æ€§çš„å…ƒç´ 
    document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        element.textContent = getText(key);
    });
    
    // æ›´æ–°placeholder
    document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
        const key = element.getAttribute('data-i18n-placeholder');
        element.placeholder = getText(key);
    });
    
    // æ›´æ–°åŠ¨æ€çŠ¶æ€æ–‡æœ¬
    const previewStatus = document.getElementById('previewStatus');
    if (previewStatus && previewStatus.textContent) {
        const statusText = previewStatus.textContent.trim();
        if (statusText === 'å®æ—¶æ›´æ–°' || statusText === 'Real-time update') {
            previewStatus.textContent = getText('realtimeUpdate');
        } else if (statusText === 'ç­‰å¾…è¾“å…¥' || statusText === 'Waiting for input') {
            previewStatus.textContent = getText('waitingInput');
        } else if (statusText === 'å·²æ›´æ–°' || statusText === 'Updated') {
            previewStatus.textContent = getText('updated');
        } else if (statusText === 'æ ¼å¼é”™è¯¯' || statusText === 'Format error') {
            previewStatus.textContent = getText('formatError');
        } else if (statusText === 'å°ºå¯¸æ— æ•ˆ' || statusText === 'Invalid size') {
            previewStatus.textContent = getText('invalidSize');
        }
    }
}

// åˆå§‹åŒ–è¯­è¨€
function initLanguage() {
    // ä¼˜å…ˆä½¿ç”¨æœ¬åœ°å­˜å‚¨çš„è¯­è¨€è®¾ç½®
    const savedLang = localStorage.getItem('svgstudio_language');
    if (savedLang && i18nData[savedLang]) {
        currentLanguage = savedLang;
    } else {
        // å¦åˆ™æ ¹æ®æµè§ˆå™¨è¯­è¨€è‡ªåŠ¨æ£€æµ‹
        currentLanguage = detectBrowserLanguage();
    }
    
    updatePageTitle();
    
    // è®¾ç½®è¯­è¨€åˆ‡æ¢æŒ‰é’®çŠ¶æ€
    document.querySelectorAll('.lang-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    const activeBtn = document.querySelector(`[onclick="switchLanguage('${currentLanguage}')"]`);
    if (activeBtn) {
        activeBtn.classList.add('active');
    }
}

// ä¸»è¦åŠŸèƒ½å˜é‡
let currentSVG = '';



// å°ºå¯¸è®¾ç½®åŠŸèƒ½
function setSize(width, height) {
    document.getElementById('widthInput').value = width;
    document.getElementById('heightInput').value = height;
    if (currentSVG) {
        updatePreview(false);
    }
}

// å¸ƒå±€æ›´æ–°åŠŸèƒ½
function updateLayout() {
    const width = parseInt(document.getElementById('widthInput').value) || 400;
    const height = parseInt(document.getElementById('heightInput').value) || 400;
    const content = document.querySelector('.content');

    // å½“å®½åº¦æˆ–é«˜åº¦å¤§äº600pxæ—¶ï¼Œåˆ‡æ¢åˆ°å‚ç›´å¸ƒå±€
    if (width > 600 || height > 600) {
        content.classList.add('vertical-layout');
    } else {
        content.classList.remove('vertical-layout');
    }
}

// é¢„è§ˆæ›´æ–°åŠŸèƒ½
function updatePreview() {
    const svgInput = document.getElementById('svgInput').value.trim();
    const width = 512;
    const height = 512;
    if (!svgInput) { updatePreviewStatus(getText('waitingInput'), 'text-gray-400'); return; }
    if (!width || !height || width <= 0 || height <= 0) { updatePreviewStatus(getText('invalidSize'), 'text-red-500'); return; }
    try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(svgInput, 'image/svg+xml');
        let svgElement = null;
        const root = doc && doc.documentElement;
        const isSvgRoot = root && (root.tagName || root.nodeName) && (root.tagName || root.nodeName).toLowerCase() === 'svg';
        if (isSvgRoot) {
            svgElement = root;
        } else {
            const alt = new DOMParser().parseFromString(svgInput, 'text/html');
            const found = alt.querySelector && alt.querySelector('svg');
            if (found) {
                svgElement = found;
            } else {
                throw new Error(getText('svgFormatError'));
            }
        }
        svgElement.setAttribute('width', width);
        svgElement.setAttribute('height', height);
        const previewContainer = document.getElementById('previewContent');
        if (!previewContainer) { console.error('Preview container element not found'); return; }
        previewContainer.innerHTML = '';
        previewContainer.appendChild(svgElement.cloneNode(true));
        previewContainer.parentElement.classList.add('has-content');
        currentSVG = new XMLSerializer().serializeToString(svgElement);
        // å…ƒç´ å¯èƒ½ä¸å­˜åœ¨ï¼Œè®¿é—®å‰åšä¿æŠ¤
        const chromeBtn = document.getElementById('chromePackBtn');
        if (chromeBtn) chromeBtn.disabled = false;
        updateExportButtonsState();
        updateLayout();
        updatePreviewStatus(getText('updated'), 'text-green-500');
    } catch (error) {
        updatePreviewStatus(getText('formatError'), 'text-red-500');
        console.error('SVG parsing error:', error.message);
    }
}

// Chrome å›¾æ ‡æ‰“åŒ…ä¸‹è½½åŠŸèƒ½
function downloadChromeIconPack() {
    if (!currentSVG) {
        showError('è¯·å…ˆè¾“å…¥ SVG ä»£ç ');
        return;
    }

    // Chrome æ‰©å±•å›¾æ ‡è§„æ ¼
    const iconSizes = [
        { size: 16, description: 'æµè§ˆå™¨å·¥å…·æ å›¾æ ‡' },
        { size: 32, description: 'æ‰©å±•ç®¡ç†é¡µé¢å›¾æ ‡' },
        { size: 48, description: 'æ‰©å±•è¯¦æƒ…é¡µé¢å›¾æ ‡' },
        { size: 128, description: 'Chromeç½‘ä¸Šåº”ç”¨åº—å›¾æ ‡' }
    ];

    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const chromePackBtn = document.getElementById('chromePackBtn');
    const originalText = chromePackBtn ? chromePackBtn.innerHTML : '';
    if (chromePackBtn) {
        chromePackBtn.innerHTML = '<div class="loading-spinner"></div><span>æ‰“åŒ…ä¸­...</span>';
        chromePackBtn.disabled = true;
    }

    // åˆ›å»º ZIP æ–‡ä»¶
    const zip = new JSZip();
    let completedIcons = 0;

    // ç”Ÿæˆæ¯ä¸ªå°ºå¯¸çš„å›¾æ ‡
    iconSizes.forEach(({ size, description }) => {
        generateIconPNG(size, (blob) => {
            if (blob) {
                zip.file(`icon_${size}x${size}.png`, blob);
                completedIcons++;

                // æ‰€æœ‰å›¾æ ‡ç”Ÿæˆå®Œæˆåï¼Œåˆ›å»ºå¹¶ä¸‹è½½ ZIP
                if (completedIcons === iconSizes.length) {
                    // æ·»åŠ è¯´æ˜æ–‡ä»¶
                    const readmeContent = `Chrome æ‰©å±•å›¾æ ‡åŒ…\n\n` +
                        `åŒ…å«ä»¥ä¸‹å›¾æ ‡æ–‡ä»¶ï¼š\n` +
                        `- icon_16x16.png: 16Ã—16 åƒç´ ï¼Œç”¨äºæµè§ˆå™¨å·¥å…·æ ï¼Œéœ€è¦ç®€æ´æ¸…æ™°\n` +
                        `- icon_32x32.png: 32Ã—32 åƒç´ ï¼Œç”¨äºæ‰©å±•ç®¡ç†é¡µé¢\n` +
                        `- icon_48x48.png: 48Ã—48 åƒç´ ï¼Œç”¨äºæ‰©å±•è¯¦æƒ…é¡µé¢\n` +
                        `- icon_128x128.png: 128Ã—128 åƒç´ ï¼Œç”¨äºChromeç½‘ä¸Šåº”ç”¨åº—ï¼Œéœ€è¦æœ€é«˜è´¨é‡\n\n` +
                        `ä½¿ç”¨æ–¹æ³•ï¼š\n` +
                        `åœ¨ manifest.json ä¸­é…ç½®ï¼š\n` +
                        `"icons": {\n` +
                        `  "16": "icon_16x16.png",\n` +
                        `  "32": "icon_32x32.png",\n` +
                        `  "48": "icon_48x48.png",\n` +
                        `  "128": "icon_128x128.png"\n` +
                        `}`;
                    
                    zip.file('README.txt', readmeContent);

                    // ç”Ÿæˆå¹¶ä¸‹è½½ ZIP æ–‡ä»¶
                    zip.generateAsync({ type: 'blob' })
                        .then(function (content) {
                            const url = URL.createObjectURL(content);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'icons.zip';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);

                            showSuccess('Chrome å›¾æ ‡åŒ…å·²ä¸‹è½½ (icons.zip)');

                            // æ¢å¤æŒ‰é’®çŠ¶æ€
                            if (chromePackBtn) { chromePackBtn.innerHTML = originalText; chromePackBtn.disabled = false; }
                        })
                        .catch(function (error) {
                            showError('ç”Ÿæˆ ZIP æ–‡ä»¶æ—¶å‡ºé”™');
                            if (chromePackBtn) { chromePackBtn.innerHTML = originalText; chromePackBtn.disabled = false; }
                        });
                }
            } else {
                showError(`ç”Ÿæˆ ${size}Ã—${size} å›¾æ ‡æ—¶å‡ºé”™`);
                if (chromePackBtn) { chromePackBtn.innerHTML = originalText; chromePackBtn.disabled = false; }
            }
        });
    });
}

// ç”ŸæˆæŒ‡å®šå°ºå¯¸çš„ PNG å›¾æ ‡
function generateIconPNG(size, callback) {
    // åˆ›å»º canvas
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    // è®¾ç½®é€æ˜èƒŒæ™¯ï¼ˆChrome å›¾æ ‡é€šå¸¸ä½¿ç”¨é€æ˜èƒŒæ™¯ï¼‰
    ctx.clearRect(0, 0, size, size);

    // åˆ›å»º Image å¯¹è±¡
    const img = new Image();

    img.onload = function () {
        try {
            // ç»˜åˆ¶åˆ° canvas
            ctx.drawImage(img, 0, 0, size, size);

            // è½¬æ¢ä¸º blob
            canvas.toBlob(function (blob) {
                callback(blob);
            }, 'image/png');
        } catch (error) {
            callback(null);
        }
    };

    img.onerror = function () {
        callback(null);
    };

    // å°† SVG è½¬æ¢ä¸º data URL
    const svgBlob = new Blob([currentSVG], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);
    img.src = url;
}

// å¤šé€‰å°ºå¯¸åŠŸèƒ½
let selectedSizes = [];

function selectAllSizes() {
    const sizeOptions = document.querySelectorAll('.size-option');
    sizeOptions.forEach(option => {
        if (!option.classList.contains('selected')) {
            option.classList.add('selected');
            const size = parseInt(option.dataset.size);
            if (!selectedSizes.includes(size)) {
                selectedSizes.push(size);
            }
        }
    });
    updateSelectedSizes();
}

function clearAllSizes() {
    const sizeOptions = document.querySelectorAll('.size-option');
    sizeOptions.forEach(option => {
        option.classList.remove('selected');
    });
    selectedSizes = [];
    updateSelectedSizes();
}

function updateSelectedSizes() {
    const countElement = document.getElementById('selectedCount');
    const count = selectedSizes.length;
    countElement.textContent = getText('selectedSizesCount').replace('{count}', count);
    
    // æ›´æ–°å°ºå¯¸è®¡æ•°å¾½ç« 
    const badge = document.getElementById('sizeBadge');
    if (badge) {
        badge.textContent = count;
        badge.style.display = count > 0 ? 'inline-block' : 'none';
    }
    
    // æ›´æ–°å¯¼å‡ºæŒ‰é’®çŠ¶æ€
    updateExportButtonsState();
}

// ç»Ÿä¸€çš„å°ºå¯¸é…ç½®
const COMMON_SIZES = [16, 24, 32, 48, 64, 128, 256, 512];

// ç”Ÿæˆå°ºå¯¸ç½‘æ ¼
function generateSizeGrid() {
    const sizeGrid = document.getElementById('sizeGrid');
    if (!sizeGrid) return;
    
    sizeGrid.innerHTML = '';
    
    COMMON_SIZES.forEach(size => {
        const sizeOption = document.createElement('button');
        sizeOption.className = 'size-option';
        sizeOption.textContent = `${size}Ã—${size}`;
        sizeOption.dataset.size = size;
        sizeOption.onclick = () => toggleSizeSelection(sizeOption, size);
        sizeGrid.appendChild(sizeOption);
    });
}

// åˆ‡æ¢å°ºå¯¸é€‰æ‹©
function toggleSizeSelection(buttonElement, size) {
    const isSelected = buttonElement.classList.contains('selected');
    
    if (isSelected) {
        buttonElement.classList.remove('selected');
        selectedSizes = selectedSizes.filter(s => s !== size);
    } else {
        buttonElement.classList.add('selected');
        selectedSizes.push(size);
    }
    
    updateSelectedSizes();
}

// ç”Ÿæˆé¢„è®¾å°ºå¯¸ç½‘æ ¼
function generatePresetGrid() {
    const presetGrid = document.getElementById('presetGrid');
    if (!presetGrid) return;
    
    presetGrid.innerHTML = '';
    
    COMMON_SIZES.forEach(size => {
        const presetBtn = document.createElement('button');
        presetBtn.className = 'preset-btn';
        presetBtn.textContent = `${size}Ã—${size}`;
        presetBtn.onclick = () => setPresetSize(size, size, presetBtn);
        presetGrid.appendChild(presetBtn);
    });
}

// è®¾ç½®é¢„è®¾å°ºå¯¸
function setPresetSize(width, height, buttonElement) {
    document.querySelectorAll('.preset-btn').forEach(btn => { btn.classList.remove('active'); });
    buttonElement.classList.add('active');
    if (currentSVG) { updatePreview(false); }
    updateLayout();
}

// æ›´æ–°é¢„è®¾æŒ‰é’®çŠ¶æ€
function updatePresetButtonsState() {
    const width = parseInt(document.getElementById('widthInput').value);
    const height = parseInt(document.getElementById('heightInput').value);
    
    // ç§»é™¤æ‰€æœ‰æŒ‰é’®çš„activeçŠ¶æ€
    document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // å¦‚æœå½“å‰å°ºå¯¸åŒ¹é…æŸä¸ªé¢„è®¾ï¼Œé«˜äº®å¯¹åº”æŒ‰é’®
    if (width === height) {
        const matchingBtn = Array.from(document.querySelectorAll('.preset-btn')).find(btn => {
            return btn.textContent === `${width}Ã—${height}`;
        });
        if (matchingBtn) {
            matchingBtn.classList.add('active');
        }
    }
}

function initializeTabs() {
    // ç”Ÿæˆå°ºå¯¸ç½‘æ ¼
    generateSizeGrid();
    
    // åˆå§‹åŒ–å°ºå¯¸è®¡æ•°å¾½ç« 
    const badge = document.getElementById('sizeBadge');
    if (badge) {
        badge.style.display = 'none';
    }
}

function updateExportButtonsState() {
    const hasSelection = selectedSizes.length > 0;
    const hasPreview = currentSVG && currentSVG.trim() !== '';
    
    // æ›´æ–°æ‰¹é‡å¯¼å‡ºæŒ‰é’®çŠ¶æ€
    const batchExportBtn = document.getElementById('batchExportBtn');
    if (batchExportBtn) {
        batchExportBtn.disabled = !hasSelection || !hasPreview;
    }
    const batchExportIcoBtn = document.getElementById('batchExportIcoBtn');
    if (batchExportIcoBtn) {
        batchExportIcoBtn.disabled = !hasSelection || !hasPreview;
    }
    const exportAllBtn = document.getElementById('exportAllPacksBtn');
    if (exportAllBtn) {
        exportAllBtn.disabled = !hasPreview;
    }
    const openSelector = document.getElementById('openExportSelectorBtn');
    if (openSelector) openSelector.disabled = !hasPreview;
}

// ICO æ–‡ä»¶ä¸‹è½½åŠŸèƒ½
function downloadICO() {
    if (!currentSVG) {
        showError('è¯·å…ˆè¾“å…¥ SVG ä»£ç å¹¶é¢„è§ˆ');
        return;
    }

    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const icoBtn = document.getElementById('icoBtn');
    if (!icoBtn) { console.warn('ICO button element not found'); return; }
    const originalText = icoBtn.innerHTML;
    icoBtn.innerHTML = '<div class="loading-spinner"></div><span>ç”Ÿæˆä¸­...</span>';
    icoBtn.disabled = true;

    // ICO æ–‡ä»¶æ”¯æŒçš„æ ‡å‡†å°ºå¯¸
    const sizes = [16, 32, 48, 256];
    let completedIcons = 0;
    const pngImages = [];

    sizes.forEach((size, index) => {
        generateIconPNG(size, function (blob) {
            if (blob) {
                // å°† blob è½¬æ¢ä¸º ArrayBuffer
                const reader = new FileReader();
                reader.onload = function () {
                    pngImages[index] = new Uint8Array(reader.result);
                    completedIcons++;

                    if (completedIcons === sizes.length) {
                        // æ‰€æœ‰å›¾æ ‡ç”Ÿæˆå®Œæˆï¼Œåˆ›å»º ICO æ–‡ä»¶
                        try {
                            const icoData = pngToIco(pngImages);
                            const icoBlob = new Blob([new Uint8Array(icoData)], { type: 'image/x-icon' });
                            
                            // åˆ›å»ºä¸‹è½½é“¾æ¥
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(icoBlob);
                            a.download = 'icon.ico';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            
                            showSuccess('ICO æ–‡ä»¶ä¸‹è½½æˆåŠŸï¼åŒ…å« 16x16ã€32x32ã€48x48ã€256x256 å››ç§å°ºå¯¸');
                        } catch (error) {
                            showError('ICO æ–‡ä»¶ç”Ÿæˆå¤±è´¥: ' + error.message);
                        }
                    }
                };
                reader.readAsArrayBuffer(blob);
            } else {
                showError(`ç”Ÿæˆ ${size}x${size} å›¾æ ‡å¤±è´¥`);
            }

            // æ¢å¤æŒ‰é’®çŠ¶æ€
            if (completedIcons === sizes.length || blob === null) {
                icoBtn.innerHTML = originalText;
                icoBtn.disabled = false;
            }
        });
    });
}

// PNG è½¬ ICO æ ¼å¼çš„æ ¸å¿ƒå‡½æ•°
function pngToIco(images) {
    let icoHead = [ // .ico æ–‡ä»¶å¤´
        0, 0, // Reserved. Must always be 0 (2 bytes)
        1, 0, // Specifies image type: 1 for icon (.ICO) image (2 bytes)
        images.length & 255, (images.length >> 8) & 255 // Number of images (2 bytes)
    ];
    let icoBody = [];
    let pngBody = [];

    for (let i = 0, num, pngHead, pngData, offset = 0; i < images.length; i++) {
        pngData = Array.from(images[i]);
        pngHead = [ // Image directory (16 bytes)
            0,    // Width 0-255, should be 0 if 256 pixels (1 byte)
            0,    // Height 0-255, should be 0 if 256 pixels (1 byte)
            0,    // Color count, should be 0 if more than 256 colors (1 byte)
            0,    // Reserved, should be 0 (1 byte)
            1, 0, // Color planes (2 bytes)
            32, 0 // Bits per pixel (2 bytes)
        ];
        
        // Size of the bitmap data in bytes (4 bytes)
        num = pngData.length;
        for (let j = 0; j < 4; j++) {
            pngHead[pngHead.length] = (num >> (8 * j)) & 255;
        }

        // Offset in the file (4 bytes)
        num = icoHead.length + ((pngHead.length + 4) * images.length) + offset;
        for (let j = 0; j < 4; j++) {
            pngHead[pngHead.length] = (num >> (8 * j)) & 255;
        }

        offset += pngData.length;
        icoBody = icoBody.concat(pngHead); // Combine image directory
        pngBody = pngBody.concat(pngData); // Combine actual image data
    }
    
    return icoHead.concat(icoBody, pngBody);
}

// å®æ—¶é¢„è§ˆåŠŸèƒ½
let previewUpdateTimeout;

function updatePreviewStatus(status, color = 'text-gray-500') {
    const statusElement = document.getElementById('statusIndicator');
    if (statusElement) {
        statusElement.textContent = status;
        statusElement.className = `text-xs ml-2 font-normal ${color}`;
    }
}

function updateSVGSize() {
    const svgInput = document.getElementById('svgInput').value;
    const sizeElement = document.getElementById('svgSize');
    if (sizeElement && svgInput) {
        const sizeInBytes = new Blob([svgInput]).size;
        let sizeText = '';
        if (sizeInBytes < 1024) {
            sizeText = `${sizeInBytes} B`;
        } else if (sizeInBytes < 1024 * 1024) {
            sizeText = `${(sizeInBytes / 1024).toFixed(1)} KB`;
        } else {
            sizeText = `${(sizeInBytes / (1024 * 1024)).toFixed(1)} MB`;
        }
        sizeElement.textContent = `(${sizeText})`;
    } else if (sizeElement) {
        sizeElement.textContent = '';
    }
}

function showPreviewLoading() {
    updatePreviewStatus(getText('updatingPreview'), 'text-blue-500');
    const previewContainer = document.getElementById('previewContent');
    if (!previewContainer) {
        console.error('Preview container element not found');
        return;
    }
    previewContainer.innerHTML = `
        <div class="preview-placeholder">
            <div class="loading-spinner" style="width: 32px; height: 32px; margin-bottom: 1rem;"></div>
            <p>æ­£åœ¨æ›´æ–°é¢„è§ˆ...</p>
        </div>
    `;
}

function updatePreviewRealtime() {
    const svgInput = document.getElementById('svgInput').value.trim();
    
    if (!svgInput) {
        // æ¸…ç©ºé¢„è§ˆ
        const previewContainer = document.getElementById('previewContent');
        if (!previewContainer) {
            console.error('Preview container element not found');
            return;
        }
        previewContainer.innerHTML = `
            <div class="preview-placeholder">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
                </svg>
                <p>åœ¨å·¦ä¾§è¾“å…¥ SVG ä»£ç ï¼Œé¢„è§ˆå°†è‡ªåŠ¨æ›´æ–°</p>
            </div>
        `;
        previewContainer.parentElement.classList.remove('has-content');
        const d1 = document.getElementById('downloadBtn'); if (d1) d1.disabled = true;
        const d2 = document.getElementById('icoBtn'); if (d2) d2.disabled = true;
        const d3 = document.getElementById('chromePackBtn'); if (d3) d3.disabled = true;
        currentSVG = '';
        return;
    }
    
    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    showPreviewLoading();
    
    // ç¨å¾®å»¶è¿Ÿä¸€ä¸‹ï¼Œè®©ç”¨æˆ·çœ‹åˆ°åŠ è½½çŠ¶æ€
    setTimeout(() => {
        // é™é»˜æ›´æ–°é¢„è§ˆï¼ˆä¸æ˜¾ç¤ºæˆåŠŸæç¤ºï¼‰
        updatePreview(false);
    }, 100);
}

function generateManifestFile(files) {
    const now = new Date().toLocaleString();

    const generateTree = (title, fileList) => {
        let tree = `${title}\n============================\n`;
        tree += `${i18nData[currentLanguage]['manifestGenerated']} ${now}\n\n`;
        fileList.forEach((file, index) => {
            const isLast = index === fileList.length - 1;
            tree += `${isLast ? 'â””â”€â”€' : 'â”œâ”€â”€'} ${file}\n`;
        });
        return tree;
    };

    const en_files = files.map(f => f.replace(getText('readmeFilename', {lang: 'zh-CN'}), i18nData['en']['readmeFilename']));
    const zh_TW_files = files.map(f => f.replace(getText('readmeFilename', {lang: 'zh-CN'}), i18nData['zh-TW']['readmeFilename']));

    const en_tree = generateTree(i18nData['en']['manifestTitle'], en_files);
    const zh_CN_tree = generateTree(i18nData['zh-CN']['manifestTitle'], files);
    const zh_TW_tree = generateTree(i18nData['zh-TW']['manifestTitle'], zh_TW_files);


    return `${en_tree}\n\n${zh_CN_tree}\n\n${zh_TW_tree}`;
}

// æ‰¹é‡å¯¼å‡ºPNGåŠŸèƒ½
function batchExportPNG() {
    if (!currentSVG) {
        showError('è¯·å…ˆè¾“å…¥ SVG ä»£ç å¹¶é¢„è§ˆ');
        return;
    }

    if (selectedSizes.length === 0) {
        showError('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå¯¼å‡ºå°ºå¯¸');
        return;
    }

    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const batchBtn = document.getElementById('batchExportBtn');
    if (!batchBtn) {
        console.error('Batch export button element not found');
        return;
    }
    const originalText = batchBtn.innerHTML;
    batchBtn.innerHTML = '<div class="loading-spinner"></div><span>æ‰¹é‡ç”Ÿæˆä¸­...</span>';
    batchBtn.disabled = true;

    // åˆ›å»ºZIPæ–‡ä»¶
    const zip = new JSZip();
    let completedCount = 0;
    const totalCount = selectedSizes.length;

    selectedSizes.forEach(size => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = size;
        canvas.height = size;

        const img = new Image();
        img.onload = function () {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            canvas.toBlob(function (blob) {
                if (blob) {
                    zip.file(`icon_${size}x${size}.png`, blob);
                    completedCount++;

                    // æ›´æ–°è¿›åº¦
                    batchBtn.innerHTML = `<div class="loading-spinner"></div><span>ç”Ÿæˆä¸­... (${completedCount}/${totalCount})</span>`;

                    if (completedCount === totalCount) {
                        // æ‰€æœ‰å›¾ç‰‡ç”Ÿæˆå®Œæˆï¼Œåˆ›å»ºZIPæ–‡ä»¶
                        const fileList = selectedSizes.map(size => `icon_${size}x${size}.png`);
                        const manifestContent = generateManifestFile(fileList);
                        zip.file(getText('manifestFile'), manifestContent);

                        zip.generateAsync({ type: 'blob' }).then(function (content) {
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(content);
                            a.download = 'icons_batch.zip';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);

                            // æ¢å¤æŒ‰é’®çŠ¶æ€
                            batchBtn.innerHTML = originalText;
                            batchBtn.disabled = false;

                            showSuccess(`æ‰¹é‡å¯¼å‡ºæˆåŠŸï¼å·²ç”Ÿæˆ ${totalCount} ä¸ªå°ºå¯¸çš„PNGæ–‡ä»¶`);
                        }).catch(function (error) {
                            batchBtn.innerHTML = originalText;
                            batchBtn.disabled = false;
                            showError('ZIPæ–‡ä»¶ç”Ÿæˆå¤±è´¥: ' + error.message);
                        });
                    }
                } else {
                    batchBtn.innerHTML = originalText;
                    batchBtn.disabled = false;
                    showError(`ç”Ÿæˆ ${size}x${size} å›¾ç‰‡å¤±è´¥`);
                }
            }, 'image/png');
        };

        img.onerror = function () {
            batchBtn.innerHTML = originalText;
            batchBtn.disabled = false;
            showError(`åŠ è½½ ${size}x${size} å›¾ç‰‡å¤±è´¥`);
        };

        const svgBlob = new Blob([currentSVG], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);
        img.src = url;
    });
}

// æ‰¹é‡å¯¼å‡ºICOåŠŸèƒ½
function batchExportICO() {
    if (!currentSVG) {
        showError('è¯·å…ˆè¾“å…¥ SVG ä»£ç å¹¶é¢„è§ˆ');
        return;
    }

    if (selectedSizes.length === 0) {
        showError('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå¯¼å‡ºå°ºå¯¸');
        return;
    }

    const icoBatchBtn = document.getElementById('batchExportIcoBtn');
    if (!icoBatchBtn) {
        console.error('Batch export ICO button element not found');
        return;
    }
    const originalText = icoBatchBtn.innerHTML;
    icoBatchBtn.innerHTML = '<div class="loading-spinner"></div><span>æ‰¹é‡ç”Ÿæˆä¸­...</span>';
    icoBatchBtn.disabled = true;

    const zip = new JSZip();
    let completedCount = 0;
    const totalCount = selectedSizes.length;

    // é€å°ºå¯¸ç”Ÿæˆ ICOï¼ˆæ¯ä¸ª ICO å†…ä»…è¯¥å°ºå¯¸ï¼Œä¾¿äºæŒ‰éœ€åˆ†å‘ï¼‰
    selectedSizes.forEach(size => {
        generateIconPNG(size, function (blob) {
            if (!blob) {
                icoBatchBtn.innerHTML = originalText;
                icoBatchBtn.disabled = false;
                showError(`ç”Ÿæˆ ${size}x${size} PNG å¤±è´¥`);
                return;
            }

            const reader = new FileReader();
            reader.onload = function () {
                try {
                    const pngArray = new Uint8Array(reader.result);
                    // åˆ©ç”¨ç°æœ‰ pngToIcoï¼Œå°†å•ä¸ª PNG å°è£…æˆå•å°ºå¯¸ ICO
                    const icoData = pngToIco([pngArray]);
                    const icoBlob = new Blob([new Uint8Array(icoData)], { type: 'image/x-icon' });
                    zip.file(`icon_${size}x${size}.ico`, icoBlob);
                    completedCount++;

                    // æ›´æ–°è¿›åº¦
                    icoBatchBtn.innerHTML = `<div class="loading-spinner"></div><span>ç”Ÿæˆä¸­... (${completedCount}/${totalCount})</span>`;

                    if (completedCount === totalCount) {
                        const fileList = selectedSizes.map(size => `icon_${size}x${size}.ico`);
                        const manifestContent = generateManifestFile(fileList);
                        zip.file(getText('manifestFile'), manifestContent);

                        zip.generateAsync({ type: 'blob' }).then(function (content) {
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(content);
                            a.download = 'icons_ico_batch.zip';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);

                            icoBatchBtn.innerHTML = originalText;
                            icoBatchBtn.disabled = false;
                            showSuccess(`æ‰¹é‡å¯¼å‡ºæˆåŠŸï¼å·²ç”Ÿæˆ ${totalCount} ä¸ªå°ºå¯¸çš„ICOæ–‡ä»¶`);
                        }).catch(function (error) {
                            icoBatchBtn.innerHTML = originalText;
                            icoBatchBtn.disabled = false;
                            showError('ZIPæ–‡ä»¶ç”Ÿæˆå¤±è´¥: ' + error.message);
                        });
                    }
                } catch (err) {
                    icoBatchBtn.innerHTML = originalText;
                    icoBatchBtn.disabled = false;
                    showError('ICO æ–‡ä»¶ç”Ÿæˆå¤±è´¥: ' + err.message);
                }
            };
            reader.readAsArrayBuffer(blob);
        });
    });
}

// æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½
function handleFileUpload(file) {
    if (!file) return;

    if (!file.type.includes('svg') && !file.name.toLowerCase().endsWith('.svg')) {
        showError(getText('errorValidSVGFile'));
        return;
    }

    const reader = new FileReader();
    reader.onload = function (e) {
        const svgContent = e.target.result;
        document.getElementById('svgInput').value = svgContent;
        showSuccess(getText('successFileUpload').replace('{name}', file.name));

        // æ›´æ–°SVGå¤§å°æ˜¾ç¤º
        updateSVGSize();
        
        // è‡ªåŠ¨æ›´æ–°é¢„è§ˆ
        setTimeout(() => {
            updatePreview();
        }, 100);
    };

    reader.onerror = function () {
        showError(getText('errorFileRead'));
    };

    reader.readAsText(file);
}

// æ˜¾ç¤ºç²˜è´´æŒ‡ç¤ºå™¨
function showPasteIndicator(message = getText('pasteReady')) {
    const indicator = document.getElementById('pasteIndicator');
    indicator.textContent = message;
    indicator.classList.add('show');
    
    setTimeout(() => {
        indicator.classList.remove('show');
    }, 2000);
}

// Tabåˆ‡æ¢åŠŸèƒ½
function switchTab() { /* tabs removed */ }

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    initLanguage();
    updateAllTexts();
    generatePresetGrid();
    initializeTabs();
    
    // è‡ªåŠ¨æ›´æ–°é¢„è§ˆå½“è¾“å…¥æ”¹å˜æ—¶
    document.getElementById('svgInput').addEventListener('input', function () {
        // æ˜¾ç¤ºæ­£åœ¨è¾“å…¥çŠ¶æ€
        updatePreviewStatus(getText('inputting'), 'text-blue-400');
        
        // æ›´æ–°æ–‡ä»¶å¤§å°æ˜¾ç¤º
        updateSVGSize();
        
        // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
        clearTimeout(previewUpdateTimeout);
        
        // è®¾ç½®æ–°çš„å®šæ—¶å™¨ï¼Œå‡å°‘å»¶è¿Ÿæ—¶é—´ä»¥æä¾›æ›´å®æ—¶çš„ä½“éªŒ
        previewUpdateTimeout = setTimeout(updatePreviewRealtime, 300);
    });
    
    // ç›‘å¬ç²˜è´´äº‹ä»¶ï¼Œæ”¯æŒæ–‡ä»¶å’Œæ–‡æœ¬ç²˜è´´
    document.getElementById('svgInput').addEventListener('paste', function (e) {
        // æ£€æŸ¥å‰ªè´´æ¿ä¸­æ˜¯å¦æœ‰æ–‡ä»¶
        const items = e.clipboardData.items;
        let hasFile = false;
        
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            
            // å¤„ç†æ–‡ä»¶ç²˜è´´
            if (item.kind === 'file') {
                const file = item.getAsFile();
                if (file && (file.type.includes('svg') || file.name.toLowerCase().endsWith('.svg'))) {
                    e.preventDefault();
                    handleFileUpload(file);
                    hasFile = true;
                    break;
                }
            }
        }
        
        // å¦‚æœæ²¡æœ‰æ–‡ä»¶ï¼Œå¤„ç†æ–‡æœ¬ç²˜è´´
        if (!hasFile) {
            // ç²˜è´´åç¨å¾®å»¶è¿Ÿä¸€ä¸‹è®©å†…å®¹å…ˆå¡«å……
            setTimeout(updatePreviewRealtime, 50);
        }
    });
    
    // æ£€æµ‹ Ctrl+V æŒ‰é”®ï¼Œæ˜¾ç¤ºç²˜è´´æç¤º
    document.addEventListener('keydown', function (e) {
        if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
            // æ£€æŸ¥å‰ªè´´æ¿æƒé™å¹¶æ˜¾ç¤ºæç¤º
            if (navigator.clipboard) {
                showPasteIndicator('ç²˜è´´ SVG æ–‡ä»¶æˆ–ä»£ç ...');
            }
        }
    });
    
    // å…¨å±€ç²˜è´´äº‹ä»¶ç›‘å¬ï¼Œæ”¯æŒåœ¨é¡µé¢ä»»ä½•åœ°æ–¹ç²˜è´´æ–‡ä»¶
    document.addEventListener('paste', function (e) {
        // å¦‚æœç„¦ç‚¹åœ¨ textarea ä¸Šï¼Œè®© textarea è‡ªå·±å¤„ç†
        if (document.activeElement === document.getElementById('svgInput')) {
            return;
        }
        
        const items = e.clipboardData.items;
        let handled = false;
        
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            
            // å¤„ç†æ–‡ä»¶ç²˜è´´
            if (item.kind === 'file') {
                const file = item.getAsFile();
                if (file && (file.type.includes('svg') || file.name.toLowerCase().endsWith('.svg'))) {
                    e.preventDefault();
                    handleFileUpload(file);
                    showSuccess(`å·²ç²˜è´´æ–‡ä»¶: ${file.name}`);
                    handled = true;
                    break;
                }
            }
            // å¤„ç†æ–‡æœ¬ç²˜è´´ï¼ˆSVG ä»£ç ï¼‰
            else if (item.kind === 'string') {
                if (item.type === 'text/plain' || item.type === 'text/html') {
                    item.getAsString((text) => {
                        // æ£€æŸ¥æ˜¯å¦æ˜¯ SVG ä»£ç 
                        if (text.trim().startsWith('<svg') && text.includes('</svg>')) {
                            e.preventDefault();
                            // æå– SVG ä»£ç ï¼ˆå¦‚æœæ˜¯ HTML ä¸­çš„ SVGï¼‰
                            let svgCode = text;
                            if (item.type === 'text/html') {
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(text, 'text/html');
                                const svgElement = doc.querySelector('svg');
                                if (svgElement) {
                                    svgCode = svgElement.outerHTML;
                                }
                            }
                            document.getElementById('svgInput').value = svgCode;
                            updatePreviewRealtime();
                            showSuccess('å·²ç²˜è´´ SVG ä»£ç ');
                            handled = true;
                        }
                    });
                }
            }
        }
        
        // å¦‚æœæ²¡æœ‰å¤„ç†ä»»ä½•å†…å®¹ï¼Œæ˜¾ç¤ºæç¤º
        if (!handled && items.length > 0) {
            showPasteIndicator('è¯·ç²˜è´´ SVG æ–‡ä»¶æˆ–ä»£ç ');
        }
    });

    // å°ºå¯¸è¾“å…¥æ”¹å˜æ—¶å®æ—¶æ›´æ–°
    ['widthInput', 'heightInput'].forEach(id => {
        document.getElementById(id).addEventListener('input', function () {
            // ç«‹å³æ›´æ–°å¸ƒå±€
            updateLayout();
            
            // æ›´æ–°é¢„è®¾æŒ‰é’®çŠ¶æ€
            updatePresetButtonsState();

            if (currentSVG) {
                clearTimeout(previewUpdateTimeout);
                previewUpdateTimeout = setTimeout(() => updatePreview(false), 200);
            }
        });
    });

    const fileInputEl = document.getElementById('fileInput');
    let isFileDialogOpen = false;

    fileInputEl.addEventListener('change', function (e) {
        const file = e.target.files[0];
        if (file) {
            handleFileUpload(file);
        }
        // æ¸…ç©ºå€¼ï¼Œä¿è¯é€‰æ‹©ç›¸åŒæ–‡ä»¶ä¹Ÿèƒ½å†æ¬¡è§¦å‘ change
        e.target.value = '';
        // å…³é—­å¯¹è¯æ¡†çŠ¶æ€
        isFileDialogOpen = false;
    });

    // é˜²æ­¢å¿«é€Ÿé‡å¤æ‰“å¼€æ–‡ä»¶é€‰æ‹©æ¡†
    fileInputEl.addEventListener('click', function (e) {
        e.stopPropagation();
    });

    // ä¸Šä¼ åŒºåŸŸç‚¹å‡»äº‹ä»¶
    document.getElementById('uploadArea').addEventListener('click', function () {
        openFileDialogOnce();
    });

    // å½“æ–‡ä»¶é€‰æ‹©çª—å£å…³é—­å›åˆ°é¡µé¢æ—¶é‡ç½®æ ‡å¿—
    window.addEventListener('focus', function () {
        isFileDialogOpen = false;
    });

    // æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½ - æ”¯æŒæ•´ä¸ªçª—å£æ‹–æ‹½
    const uploadArea = document.getElementById('uploadArea');
    let dragCounter = 0; // ç”¨äºè·Ÿè¸ªæ‹–æ‹½è¿›å…¥/ç¦»å¼€äº‹ä»¶

    // åŸæœ‰çš„ä¸Šä¼ åŒºåŸŸæ‹–æ‹½åŠŸèƒ½ä¿æŒä¸å˜
    uploadArea.addEventListener('dragover', function (e) {
        e.preventDefault();
        uploadArea.classList.add('dragover');
    });

    uploadArea.addEventListener('dragleave', function (e) {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
    });

    uploadArea.addEventListener('drop', function (e) {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        document.body.classList.remove('drag-active');
        dragCounter = 0;

        const files = e.dataTransfer.files;
        if (files.length > 0) {
            const file = files[0];
            if (file.type.includes('svg') || file.name.toLowerCase().endsWith('.svg')) {
                handleFileUpload(file);
                showSuccess(`å·²æ‹–æ‹½ä¸Šä¼ : ${file.name}`);
            } else {
                showError('è¯·æ‹–æ‹½ SVG æ ¼å¼çš„æ–‡ä»¶');
            }
        }
    });

    // å…¨çª—å£æ‹–æ‹½åŠŸèƒ½
    document.addEventListener('dragenter', function (e) {
        e.preventDefault();
        dragCounter++;
        
        // æ£€æŸ¥æ˜¯å¦æ‹–æ‹½çš„æ˜¯æ–‡ä»¶
        if (e.dataTransfer.types.includes('Files')) {
            document.body.classList.add('drag-active');
        }
    });

    document.addEventListener('dragover', function (e) {
        e.preventDefault();
        
        // æ£€æŸ¥æ˜¯å¦æ‹–æ‹½çš„æ˜¯æ–‡ä»¶
        if (e.dataTransfer.types.includes('Files')) {
            document.body.classList.add('drag-active');
        }
    });

    document.addEventListener('dragleave', function (e) {
        e.preventDefault();
        dragCounter--;
        
        // åªæœ‰å½“æ‰€æœ‰æ‹–æ‹½éƒ½ç¦»å¼€æ—¶æ‰ç§»é™¤æ ·å¼
        if (dragCounter === 0) {
            document.body.classList.remove('drag-active');
        }
    });

    document.addEventListener('drop', function (e) {
        e.preventDefault();
        dragCounter = 0;
        document.body.classList.remove('drag-active');
        
        // å¦‚æœæ‹–æ‹½åˆ°ä¸Šä¼ åŒºåŸŸï¼Œè®©ä¸Šä¼ åŒºåŸŸå¤„ç†
        if (e.target.closest('#uploadArea')) {
            return;
        }
        
        // å¤„ç†å…¨çª—å£æ‹–æ‹½
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            const file = files[0];
            if (file.type.includes('svg') || file.name.toLowerCase().endsWith('.svg')) {
                handleFileUpload(file);
                showSuccess(`å·²æ‹–æ‹½ä¸Šä¼ : ${file.name}`);
            } else {
                showError('è¯·æ‹–æ‹½ SVG æ ¼å¼çš„æ–‡ä»¶');
            }
        }
    });

    // é”®ç›˜å¿«æ·é”®ï¼ˆç²¾ç®€ï¼Œç§»é™¤ä¸‹è½½æŒ‰é’®ä¾èµ–ï¼‰
    document.addEventListener('keydown', function (e) {
        if (e.ctrlKey || e.metaKey) {
            if (e.key === 'Enter') {
                e.preventDefault();
                updatePreview();
            }
        }
    });
});

// ç§»åŠ¨ç«¯èœå•åˆ‡æ¢åŠŸèƒ½
function toggleMobileMenu() {
    const mobileNav = document.getElementById('mobileNav');
    const menuToggle = document.querySelector('.mobile-menu-toggle');
    
    if (mobileNav && menuToggle) {
        const isActive = mobileNav.classList.contains('active');
        
        if (isActive) {
            mobileNav.classList.remove('active');
            menuToggle.classList.remove('active');
        } else {
            mobileNav.classList.add('active');
            menuToggle.classList.add('active');
        }
    }
}

// ç‚¹å‡»å¯¼èˆªé“¾æ¥æ—¶å…³é—­ç§»åŠ¨ç«¯èœå•
document.addEventListener('click', function(e) {
    const mobileNav = document.getElementById('mobileNav');
    const menuToggle = document.querySelector('.mobile-menu-toggle');
    
    // å¦‚æœç‚¹å‡»çš„æ˜¯ç§»åŠ¨ç«¯å¯¼èˆªé“¾æ¥ï¼Œå…³é—­èœå•
    if (e.target.classList.contains('mobile-nav-link')) {
        if (mobileNav && menuToggle) {
            mobileNav.classList.remove('active');
            menuToggle.classList.remove('active');
        }
    }
    
    // å¦‚æœç‚¹å‡»çš„æ˜¯èœå•å¤–éƒ¨åŒºåŸŸï¼Œå…³é—­èœå•
    if (mobileNav && menuToggle && 
        !mobileNav.contains(e.target) && 
        !menuToggle.contains(e.target) &&
        mobileNav.classList.contains('active')) {
        mobileNav.classList.remove('active');
        menuToggle.classList.remove('active');
    }
});

// çª—å£å¤§å°æ”¹å˜æ—¶å…³é—­ç§»åŠ¨ç«¯èœå•
window.addEventListener('resize', function() {
    const mobileNav = document.getElementById('mobileNav');
    const menuToggle = document.querySelector('.mobile-menu-toggle');
    
    if (window.innerWidth > 768 && mobileNav && menuToggle) {
        mobileNav.classList.remove('active');
        menuToggle.classList.remove('active');
    }
});

// é”®ç›˜äº‹ä»¶å¤„ç†ï¼ˆESCé”®å…³é—­èœå•ï¼‰
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const mobileNav = document.getElementById('mobileNav');
        const menuToggle = document.querySelector('.mobile-menu-toggle');
        
        if (mobileNav && menuToggle && mobileNav.classList.contains('active')) {
            mobileNav.classList.remove('active');
            menuToggle.classList.remove('active');
        }
    }
});

// HeaderæŒ‰é’®åŠŸèƒ½å®ç°





// è¯­è¨€åˆ‡æ¢åŠŸèƒ½
function toggleLanguageDropdown() {
    const selector = document.getElementById('languageSelector');
    const dropdown = document.getElementById('languageDropdown');
    
    if (selector && dropdown) {
        selector.classList.toggle('open');
        
        // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰èœå•
        if (selector.classList.contains('open')) {
            document.addEventListener('click', closeLanguageDropdown);
        } else {
            document.removeEventListener('click', closeLanguageDropdown);
        }
    }
}

function closeLanguageDropdown(event) {
    const selector = document.getElementById('languageSelector');
    if (selector && !selector.contains(event.target)) {
        selector.classList.remove('open');
        document.removeEventListener('click', closeLanguageDropdown);
    }
}

function selectLanguage(langCode) {
    const langNames = {
        'zh-CN': 'ç®€ä½“ä¸­æ–‡',
        'zh-TW': 'ç¹é«”ä¸­æ–‡',
        'en': 'English'
    };
    
    if (langCode !== currentLanguage) {
        switchLanguage(langCode);
        showSuccess(getText('successLangSwitch', { langName: langNames[langCode] }));
    }
    
    // å…³é—­ä¸‹æ‹‰èœå•
    const selector = document.getElementById('languageSelector');
    if (selector) {
        selector.classList.remove('open');
        document.removeEventListener('click', closeLanguageDropdown);
    }
}

function updateLanguageDisplay() {
    const currentLangDisplay = document.getElementById('currentLangDisplay');
    const languageOptions = document.querySelectorAll('.language-option');
    
    const langNames = {
        'zh-CN': 'ç®€ä½“ä¸­æ–‡',
        'zh-TW': 'ç¹é«”ä¸­æ–‡',
        'en': 'English'
    };
    
    // æ›´æ–°å½“å‰è¯­è¨€æ˜¾ç¤º
    if (currentLangDisplay) {
        const name = langNames[currentLanguage] || 'ç®€ä½“ä¸­æ–‡';
        currentLangDisplay.textContent = name;
    }
    
    // æ›´æ–°é€‰é¡¹çš„æ¿€æ´»çŠ¶æ€
    languageOptions.forEach(option => {
        const langCode = option.getAttribute('data-lang');
        if (langCode === currentLanguage) {
            option.classList.add('active');
        } else {
            option.classList.remove('active');
        }
    });
}





// åœ¨DOMContentLoadedäº‹ä»¶ä¸­æ·»åŠ headeræŒ‰é’®äº‹ä»¶ç›‘å¬
document.addEventListener('DOMContentLoaded', function() {
    // æ·»åŠ è¯­è¨€é€‰æ‹©å™¨äº‹ä»¶ç›‘å¬
    const langButton = document.getElementById('languageToggle');
    
    if (langButton) {
        langButton.addEventListener('click', toggleLanguageDropdown);
    }
    
    // æ·»åŠ è¯­è¨€é€‰é¡¹ç‚¹å‡»äº‹ä»¶
    const languageOptions = document.querySelectorAll('.language-option');
    languageOptions.forEach(option => {
        option.addEventListener('click', function() {
            const langCode = this.getAttribute('data-lang');
            selectLanguage(langCode);
        });
    });
    
    // åˆå§‹åŒ–è¯­è¨€æ˜¾ç¤º
    updateLanguageDisplay();
    
    // æ·»åŠ URLåŠ è½½æŒ‰é’®äº‹ä»¶ç›‘å¬
    const urlLoadBtn = document.getElementById('urlLoadBtn');
    if (urlLoadBtn) {
        urlLoadBtn.addEventListener('click', loadFromURL);
    }
});

// è¾…åŠ©ï¼šå°†å½“å‰SVGæŒ‰å°ºå¯¸ä¸æ ¼å¼æ¸²æŸ“ä¸ºBlob
async function renderSVGToBitmapBlob(targetSize, format = 'png') {
    return new Promise((resolve, reject) => {
        try {
            const canvas = document.createElement('canvas');
            canvas.width = targetSize;
            canvas.height = targetSize;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, targetSize, targetSize);

            const img = new Image();
            img.onload = function () {
                try {
                    ctx.drawImage(img, 0, 0, targetSize, targetSize);
                    const mime = format === 'jpg' || format === 'jpeg' ? 'image/jpeg' : (format === 'webp' ? 'image/webp' : 'image/png');
                    canvas.toBlob((blob) => blob ? resolve(blob) : reject(new Error('Blob null')), mime);
                } catch (e) { reject(e); }
            };
            img.onerror = () => reject(new Error('Image load failed'));
            const svgBlob = new Blob([currentSVG], { type: 'image/svg+xml;charset=utf-8' });
            img.src = URL.createObjectURL(svgBlob);
        } catch (e) { reject(e); }
    });
}

// è§„æ ¼é…ç½®ï¼ˆæ¥è‡ªéœ€æ±‚ï¼‰
const EXPORT_SPEC = {
    web: {
        favicon: { sizes: [16, 32, 48], formats: ['ico', 'png'] },
        appleTouch: { sizes: [180], formats: ['png'] },
        pwa: { sizes: [192, 512], formats: ['png'] }
    },
    chromeExtension: { sizes: [16, 32, 48, 128], formats: ['png'] },
    android: {
        mipmap: { sizes: [48, 72, 96, 144, 192], formats: ['png', 'webp'] },
        playStore: { sizes: [512], formats: ['png'] },
        adaptiveIcon: { sizes: [108], formats: ['png'] }
    },
    ios: {
        iphone: { sizes: [80, 120, 180], formats: ['png'] },
        ipad: { sizes: [152, 167], formats: ['png'] },
        appStore: { sizes: [1024], formats: ['png'] }
    },
    desktop: {
        windows: { sizes: [16, 32, 48, 256], formats: ['ico'] },
        macos: { sizes: [16, 32, 64, 128, 256, 512, 1024], formats: ['icns'] }
    },
    social: {
        avatar: { sizes: [512], formats: ['png', 'jpg'] },
        share: { sizes: [1080, 1200], formats: ['png', 'jpg'] }
    }
};

// ç”Ÿæˆ ICOï¼ˆå¤ç”¨ç°æœ‰ pngToIcoï¼‰
async function generateIcoFromSizes(sizes) {
    const pngBuffers = [];
    for (const size of sizes) {
        const blob = await renderSVGToBitmapBlob(size, 'png');
        const buf = await blob.arrayBuffer();
        pngBuffers.push(new Uint8Array(buf));
    }
    return new Blob([new Uint8Array(pngToIco(pngBuffers))], { type: 'image/x-icon' });
}

// æ³¨æ„ï¼šICNS ç”Ÿæˆè¾ƒå¤æ‚ï¼Œè¿™é‡Œä»¥ZIPå†…æä¾›å¤šå°ºå¯¸PNGå¹¶é™„READMEè¯´æ˜æ›¿ä»£
function generateIcnsPlaceholder(zipFolder) {
    const readme = `macOS ICNS è¯´æ˜\n\n` +
        `æœ¬å·¥å…·æš‚ä¸ç›´æ¥ç”Ÿæˆ .icnsã€‚è¯·ä½¿ç”¨ Apple Icon Utility æˆ– iconutil å°† ZIP å†… PNG è½¬æ¢ä¸º ICNSï¼š\n` +
        `1) å°†ä»¥ä¸‹PNGæ”¾å…¥ MyIcon.iconset/ ç›®å½•ï¼ˆåå­—å¦‚ icon_16x16.png ç­‰ï¼‰\n` +
        `2) è¿è¡Œï¼šiconutil -c icns MyIcon.iconset\n`;
    zipFolder.file('README_ICNS.txt', readme);
}

function confirmExport(title, items) {
    try {
        const lines = items.map(i => `- ${i.name}: ${i.count}`);
        return window.confirm(`${title}\n\n${lines.join('\n')}`);
    } catch (_) { return true; }
}

function countSquareSizes(sizes) { return sizes.length; }

function getAllExportSummary() {
    const items = [];
    // square formats
    const squarePNG = new Set();
    const squareWEBP = new Set();
    const squareJPG = new Set();

    const add = (arr, set) => arr.forEach(s => set.add(s));

    add(EXPORT_SPEC.web.favicon.sizes, squarePNG); // png
    add(EXPORT_SPEC.web.appleTouch.sizes, squarePNG);
    add(EXPORT_SPEC.web.pwa.sizes, squarePNG);
    add(EXPORT_SPEC.chromeExtension.sizes, squarePNG);
    add(EXPORT_SPEC.android.mipmap.sizes, squarePNG);
    add(EXPORT_SPEC.android.playStore.sizes, squarePNG);
    add(EXPORT_SPEC.android.adaptiveIcon.sizes, squarePNG);
    add(EXPORT_SPEC.ios.iphone.sizes, squarePNG);
    add(EXPORT_SPEC.ios.ipad.sizes, squarePNG);
    add(EXPORT_SPEC.ios.appStore.sizes, squarePNG);
    add(EXPORT_SPEC.desktop.macos.sizes, squarePNG);
    add(EXPORT_SPEC.social.avatar.sizes, squarePNG);
    add(EXPORT_SPEC.social.share.sizes, squarePNG);

    // formats per spec
    // webp
    EXPORT_SPEC.android.mipmap.formats.includes('webp') && add(EXPORT_SPEC.android.mipmap.sizes, squareWEBP);
    // jpg
    add(EXPORT_SPEC.social.avatar.sizes, squareJPG);
    add(EXPORT_SPEC.social.share.sizes, squareJPG);

    items.push({ name: 'PNG', count: squarePNG.size + 1 /*1200x630*/ });
    items.push({ name: 'WEBP', count: squareWEBP.size });
    items.push({ name: 'JPG', count: squareJPG.size + 1 /*1200x630*/ });

    // ICO
    let icoCount = 0;
    if (EXPORT_SPEC.web.favicon.formats.includes('ico')) icoCount += 1; // favicon.ico
    if (EXPORT_SPEC.desktop.windows.formats.includes('ico')) icoCount += 1; // icon.ico
    items.push({ name: 'ICO', count: icoCount });

    return items;
}

async function exportAllPacks() {
    if (!currentSVG) {
        showError(getText('errorEnterSVGFirst'));
        return;
    }

    // ç¡®è®¤
    const ok = confirmExport(getText('exportAllPacks'), getAllExportSummary());
    if (!ok) return;

    const btn = document.getElementById('exportAllPacksBtn');
    if (!btn) return;
    const original = btn.innerHTML;
    btn.innerHTML = `<div class=\"loading-spinner\"></div><span>${getText('exportingAll')}</span>`;
    btn.disabled = true;

    // åˆ†æ ¼å¼æ‰“åŒ…
    const zipPNG = new JSZip();
    const zipWEBP = new JSZip();
    const zipJPG = new JSZip();
    const zipICO = new JSZip();

    try {
        // helper: add square export to zip
        const addSquare = async (sizes, formats) => {
            for (const s of sizes) {
                if (formats.includes('png')) {
                    const b = await renderSVGToBitmapBlob(s, 'png');
                    zipPNG.file(`icon_${s}.png`, b);
                }
                if (formats.includes('webp')) {
                    const b = await renderSVGToBitmapBlob(s, 'webp');
                    zipWEBP.file(`icon_${s}.webp`, b);
                }
                if (formats.includes('jpg') || formats.includes('jpeg')) {
                    const b = await renderSVGToBitmapBlob(s, 'jpg');
                    zipJPG.file(`icon_${s}.jpg`, b);
                }
            }
        };

        // WEB
        // favicon: ico + png
        if (EXPORT_SPEC.web.favicon.formats.includes('ico')) {
            const icoBlob = await generateIcoFromSizes(EXPORT_SPEC.web.favicon.sizes);
            zipICO.file('favicon.ico', icoBlob);
        }
        await addSquare(EXPORT_SPEC.web.favicon.sizes, EXPORT_SPEC.web.favicon.formats);
        await addSquare(EXPORT_SPEC.web.appleTouch.sizes, EXPORT_SPEC.web.appleTouch.formats);
        await addSquare(EXPORT_SPEC.web.pwa.sizes, EXPORT_SPEC.web.pwa.formats);

        // Chrome Extension
        await addSquare(EXPORT_SPEC.chromeExtension.sizes, EXPORT_SPEC.chromeExtension.formats);

        // Android
        await addSquare(EXPORT_SPEC.android.mipmap.sizes, EXPORT_SPEC.android.mipmap.formats);
        await addSquare(EXPORT_SPEC.android.playStore.sizes, EXPORT_SPEC.android.playStore.formats);
        await addSquare(EXPORT_SPEC.android.adaptiveIcon.sizes, EXPORT_SPEC.android.adaptiveIcon.formats);

        // iOS
        await addSquare(EXPORT_SPEC.ios.iphone.sizes, EXPORT_SPEC.ios.iphone.formats);
        await addSquare(EXPORT_SPEC.ios.ipad.sizes, EXPORT_SPEC.ios.ipad.formats);
        await addSquare(EXPORT_SPEC.ios.appStore.sizes, EXPORT_SPEC.ios.appStore.formats);

        // Desktop
        if (EXPORT_SPEC.desktop.windows.formats.includes('ico')) {
            const icoBlob = await generateIcoFromSizes(EXPORT_SPEC.desktop.windows.sizes);
            zipICO.file('icon.ico', icoBlob);
        }
        // macOS icns æš‚ä¸ç”Ÿæˆï¼ˆä¸å«è¯´æ˜æ–‡ä»¶ï¼‰
        // è‹¥åç»­éœ€è¦ï¼Œå¯åœ¨æ­¤ç”Ÿæˆ icns å¹¶å¦è¡Œæ‰“åŒ…

        // Social square
        await addSquare(EXPORT_SPEC.social.avatar.sizes, EXPORT_SPEC.social.avatar.formats);
        await addSquare(EXPORT_SPEC.social.share.sizes, EXPORT_SPEC.social.share.formats);
        // é¢å¤–å¯¼å‡º 1200x630ï¼ˆéç­‰æ¯”ï¼‰
        {
            const width = 1200; const height = 630;
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, width, height);
            const img = new Image();
            await new Promise((res, rej) => {
                img.onload = res; img.onerror = rej;
                const svgBlob = new Blob([currentSVG], { type: 'image/svg+xml;charset=utf-8' });
                img.src = URL.createObjectURL(svgBlob);
            });
            const size = Math.min(width, height);
            const x = Math.floor((width - size) / 2);
            const y = Math.floor((height - size) / 2);
            ctx.drawImage(img, x, y, size, size);
            await new Promise(r => canvas.toBlob(b => { if (b) zipPNG.file(`icon_1200x630.png`, b); r(); }, 'image/png'));
            await new Promise(r => canvas.toBlob(b => { if (b) zipJPG.file(`icon_1200x630.jpg`, b); r(); }, 'image/jpeg'));
        }

        // ä¾æ¬¡è§¦å‘ä¸‹è½½ï¼špng/webp/jpg/icoï¼ˆè‹¥ä¸ºç©ºåˆ™è·³è¿‡ï¼‰
        const triggerZip = async (zip, name) => {
            if (!zip) return;
            const files = Object.keys(zip.files || {});
            if (files.length === 0) return;
            const content = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        await triggerZip(zipPNG, 'holatiger-icon-png.zip');
        await triggerZip(zipWEBP, 'holatiger-icon-webp.zip');
        await triggerZip(zipJPG, 'holatiger-icon-jpg.zip');
        await triggerZip(zipICO, 'holatiger-icon-ico.zip');

        showSuccess(getText('successAllExport'));
    } catch (e) {
        showError(e.message || 'å¯¼å‡ºå¤±è´¥');
    } finally {
        btn.innerHTML = original;
        btn.disabled = false;
    }
}

// è½»é‡é€šçŸ¥ï¼šé¿å…ç¼ºå¤±æ–¹æ³•å¯¼è‡´æŠ¥é”™ï¼Œç»Ÿä¸€ç”¨çŠ¶æ€æ å±•ç¤º
function showSuccess(message) {
    try { console.log('[SUCCESS]', message); } catch (_) {}
    updatePreviewStatus(message || getText('updated'), 'text-green-500');
}
function showError(message) {
    try { console.error('[ERROR]', message); } catch (_) {}
    updatePreviewStatus(message || getText('formatError'), 'text-red-500');
}
function showInfo(message) {
    try { console.info('[INFO]', message); } catch (_) {}
    updatePreviewStatus(message || getText('realtimeUpdate'), 'text-blue-500');
}

function packAddReadme(zip, lines) {
    const filename = getText('readmeFilename');
    const content = [
        `Language: ${currentLanguage}`,
        '',
        ...lines
    ].join('\n');
    zip.file(filename, content);
}

function openExportModal() {
    const modal = document.getElementById('exportModal');
    const exportTree = document.getElementById('exportTree');
    if (!modal || !exportTree) return;

    if (exportTree.innerHTML === '') {
        // Dummy data for demonstration
        const packs = ['web', 'chromeExtension', 'android', 'ios', 'windows', 'macos', 'social'];
        packs.forEach(pack => {
            const node = document.createElement('div');
            node.innerHTML = `<label><input type="checkbox" value="${pack}"> ${getText('export' + pack.charAt(0).toUpperCase() + pack.slice(1))}</label>`;
            exportTree.appendChild(node);
        });

        const headerControls = document.createElement('div');
        headerControls.className = 'batch-controls';
        headerControls.innerHTML = `
          <button class="btn btn-small btn-select-all" data-i18n="selectAll" onclick="document.querySelectorAll('#exportTree input[type=checkbox]').forEach(c => c.checked = true)">${getText('selectAll')}</button>
          <button class="btn btn-small btn-clear-all" data-i18n="clearAll" onclick="document.querySelectorAll('#exportTree input[type=checkbox]').forEach(c => c.checked = false)">${getText('clearAll')}</button>
        `;
        modal.querySelector('.modal-header').appendChild(headerControls);
    }
    
    modal.classList.remove('hidden');
}

function closeExportModal() {
    const modal = document.getElementById('exportModal');
    if (modal) modal.classList.add('hidden');
}

async function confirmExportSelection() {
    // Dummy function, as implementation is complex and out of scope of the styling request
    console.log("Exporting selected packs...");
    closeExportModal();
}

async function exportWebPack() {
    if (!currentSVG) { showError(getText('errorEnterSVGFirst')); return; }
    const items = [];
    let pngCount = EXPORT_SPEC.web.favicon.sizes.length + EXPORT_SPEC.web.appleTouch.sizes.length + EXPORT_SPEC.web.pwa.sizes.length;
    let icoCount = EXPORT_SPEC.web.favicon.formats.includes('ico') ? 1 : 0;
    items.push({ name: 'PNG', count: pngCount });
    if (icoCount) items.push({ name: 'ICO', count: icoCount });
    if (!confirmExport(getText('exportWeb'), items)) return;
    const btn = document.getElementById('exportWebBtn'); if (!btn) return;
    const org = btn.innerHTML; btn.innerHTML = `<div class="loading-spinner"></div><span>${getText('exportingPack')}</span>`; btn.disabled = true;
    const zip = new JSZip();
    try {
        // favicon ico
        if (EXPORT_SPEC.web.favicon.formats.includes('ico')) {
            const icoBlob = await generateIcoFromSizes(EXPORT_SPEC.web.favicon.sizes);
            zip.file('favicon.ico', icoBlob);
        }
        // favicon/apple/pwa png
        for (const s of EXPORT_SPEC.web.favicon.sizes) { if (EXPORT_SPEC.web.favicon.formats.includes('png')) { zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png')); } }
        for (const s of EXPORT_SPEC.web.appleTouch.sizes) { zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png')); }
        for (const s of EXPORT_SPEC.web.pwa.sizes) { zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png')); }
        packAddReadme(zip, [getText('readmeWeb')]);
        const blob = await zip.generateAsync({type:'blob'});

        const fileList = Object.keys(zip.files);
        const manifestContent = generateManifestFile(fileList);
        zip.file(getText('manifestFile'), manifestContent);

        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='web-icons.zip'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        showSuccess(getText('successPackExport'));
    } catch(e){ showError(e.message);} finally { btn.innerHTML = org; btn.disabled = false; }
}

async function exportChromeExtensionPack() {
    if (!currentSVG) { showError(getText('errorEnterSVGFirst')); return; }
    const items = [{ name: 'PNG', count: EXPORT_SPEC.chromeExtension.sizes.length }];
    if (!confirmExport(getText('exportChrome'), items)) return;
    const btn = document.getElementById('exportChromeBtn'); if (!btn) return;
    const org = btn.innerHTML; btn.innerHTML = `<div class="loading-spinner"></div><span>${getText('exportingPack')}</span>`; btn.disabled = true;
    const zip = new JSZip();
    try {
        for (const s of EXPORT_SPEC.chromeExtension.sizes) { zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png')); }
        packAddReadme(zip, [getText('readmeChrome')]);
        const blob = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='chrome-extension-icons.zip'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        showSuccess(getText('successPackExport'));
    } catch(e){ showError(e.message);} finally { btn.innerHTML = org; btn.disabled = false; }
}

async function exportAndroidPack() {
    if (!currentSVG) { showError(getText('errorEnterSVGFirst')); return; }
    const pngC = EXPORT_SPEC.android.mipmap.sizes.length + EXPORT_SPEC.android.playStore.sizes.length + EXPORT_SPEC.android.adaptiveIcon.sizes.length;
    const webpC = EXPORT_SPEC.android.mipmap.formats.includes('webp') ? EXPORT_SPEC.android.mipmap.sizes.length : 0;
    const items = [{ name: 'PNG', count: pngC }]; if (webpC) items.push({ name: 'WEBP', count: webpC });
    if (!confirmExport(getText('exportAndroid'), items)) return;
    const btn = document.getElementById('exportAndroidBtn'); if (!btn) return;
    const org = btn.innerHTML; btn.innerHTML = `<div class="loading-spinner"></div><span>${getText('exportingPack')}</span>`; btn.disabled = true;
    const zip = new JSZip();
    try {
        for (const s of EXPORT_SPEC.android.mipmap.sizes) {
            zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png'));
            if (EXPORT_SPEC.android.mipmap.formats.includes('webp')) zip.file(`icon_${s}.webp`, await renderSVGToBitmapBlob(s,'webp'));
        }
        for (const s of EXPORT_SPEC.android.playStore.sizes) { zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png')); }
        for (const s of EXPORT_SPEC.android.adaptiveIcon.sizes) { zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png')); }
        packAddReadme(zip, [getText('readmeAndroid')]);
        const blob = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='android-icons.zip'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        showSuccess(getText('successPackExport'));
    } catch(e){ showError(e.message);} finally { btn.innerHTML = org; btn.disabled = false; }
}

async function exportIOSPack() {
    if (!currentSVG) { showError(getText('errorEnterSVGFirst')); return; }
    const items = [{ name: 'PNG', count: EXPORT_SPEC.ios.iphone.sizes.length + EXPORT_SPEC.ios.ipad.sizes.length + EXPORT_SPEC.ios.appStore.sizes.length }];
    if (!confirmExport(getText('exportIOS'), items)) return;
    const btn = document.getElementById('exportIOSBtn'); if (!btn) return;
    const org = btn.innerHTML; btn.innerHTML = `<div class="loading-spinner"></div><span>${getText('exportingPack')}</span>`; btn.disabled = true;
    const zip = new JSZip();
    try {
        for (const s of EXPORT_SPEC.ios.iphone.sizes) { zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png')); }
        for (const s of EXPORT_SPEC.ios.ipad.sizes) { zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png')); }
        for (const s of EXPORT_SPEC.ios.appStore.sizes) { zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png')); }
        packAddReadme(zip, [getText('readmeIOS')]);
        const blob = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='ios-icons.zip'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        showSuccess(getText('successPackExport'));
    } catch(e){ showError(e.message);} finally { btn.innerHTML = org; btn.disabled = false; }
}

async function exportWindowsPack() {
    if (!currentSVG) { showError(getText('errorEnterSVGFirst')); return; }
    const items = [{ name: 'ICO', count: EXPORT_SPEC.desktop.windows.formats.includes('ico') ? 1 : 0 }];
    if (!confirmExport(getText('exportWindows'), items)) return;
    const btn = document.getElementById('exportWindowsBtn'); if (!btn) return;
    const org = btn.innerHTML; btn.innerHTML = `<div class="loading-spinner"></div><span>${getText('exportingPack')}</span>`; btn.disabled = true;
    const zip = new JSZip();
    try {
        if (EXPORT_SPEC.desktop.windows.formats.includes('ico')) {
            const icoBlob = await generateIcoFromSizes(EXPORT_SPEC.desktop.windows.sizes);
            zip.file('icon.ico', icoBlob);
        }
        packAddReadme(zip, [getText('readmeWindows')]);
        const blob = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='windows-icons.zip'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        showSuccess(getText('successPackExport'));
    } catch(e){ showError(e.message);} finally { btn.innerHTML = org; btn.disabled = false; }
}

async function exportMacOSPack() {
    if (!currentSVG) { showError(getText('errorEnterSVGFirst')); return; }
    const items = [{ name: 'PNG', count: EXPORT_SPEC.desktop.macos.sizes.length }];
    if (!confirmExport(getText('exportMacOS'), items)) return;
    const btn = document.getElementById('exportMacOSBtn'); if (!btn) return;
    const org = btn.innerHTML; btn.innerHTML = `<div class="loading-spinner"></div><span>${getText('exportingPack')}</span>`; btn.disabled = true;
    const zip = new JSZip();
    try {
        // å…ˆå¯¼å‡ºå¤šå°ºå¯¸ PNGï¼›icns å¯ç•™åˆ°åç»­å¢å¼º
        for (const s of EXPORT_SPEC.desktop.macos.sizes) { zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png')); }
        packAddReadme(zip, [getText('readmeMacOS')]);
        const blob = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='macos-icons.zip'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        showSuccess(getText('successPackExport'));
    } catch(e){ showError(e.message);} finally { btn.innerHTML = org; btn.disabled = false; }
}

async function exportSocialPack() {
    if (!currentSVG) { showError(getText('errorEnterSVGFirst')); return; }
    const items = [
        { name: 'PNG', count: EXPORT_SPEC.social.avatar.sizes.length + EXPORT_SPEC.social.share.sizes.length + 1 },
        { name: 'JPG', count: EXPORT_SPEC.social.avatar.sizes.length + EXPORT_SPEC.social.share.sizes.length + 1 }
    ];
    if (!confirmExport(getText('exportSocial'), items)) return;
    const btn = document.getElementById('exportSocialBtn'); if (!btn) return;
    const org = btn.innerHTML; btn.innerHTML = `<div class="loading-spinner"></div><span>${getText('exportingPack')}</span>`; btn.disabled = true;
    const zip = new JSZip();
    try {
        for (const s of EXPORT_SPEC.social.avatar.sizes) {
            zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png'));
            zip.file(`icon_${s}.jpg`, await renderSVGToBitmapBlob(s,'jpg'));
        }
        for (const s of EXPORT_SPEC.social.share.sizes) {
            zip.file(`icon_${s}.png`, await renderSVGToBitmapBlob(s,'png'));
            zip.file(`icon_${s}.jpg`, await renderSVGToBitmapBlob(s,'jpg'));
        }
        // 1200x630 é¢å¤–å›¾
        const width = 1200, height = 630; const canvas = document.createElement('canvas'); canvas.width=width; canvas.height=height; const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,width,height);
        const img = new Image(); await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; const svgBlob=new Blob([currentSVG],{type:'image/svg+xml;charset=utf-8'}); img.src=URL.createObjectURL(svgBlob); });
        const size=Math.min(width,height), x=Math.floor((width-size)/2), y=Math.floor((height-size)/2); ctx.drawImage(img,x,y,size,size);
        await new Promise(r=>canvas.toBlob(b=>{ if(b) zip.file('icon_1200x630.png', b); r(); }, 'image/png'));
        await new Promise(r=>canvas.toBlob(b=>{ if(b) zip.file('icon_1200x630.jpg', b); r(); }, 'image/jpeg'));
        packAddReadme(zip, [getText('readmeSocial')]);
        const blob = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='social-icons.zip'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        showSuccess(getText('successPackExport'));
    } catch(e){ showError(e.message);} finally { btn.innerHTML = org; btn.disabled = false; }
}

// æ„å»ºå¯é€‰æ‹©çš„å¯¼å‡ºæ¸…å•ï¼ˆé€æ–‡ä»¶è§„æ ¼ï¼‰
function buildExportItems() {
    const items = [];
    const add = (group, format, sizeKey, producer, fileName) => {
        const id = `${group}|${format}|${sizeKey}|${fileName}`;
        items.push({ id, group, format, sizeKey, fileName, producer });
    };

    // helpers
    const sq = (s) => `${s}x${s}`;

    // web
    // favicon pngs
    if (EXPORT_SPEC.web.favicon.formats.includes('png')) {
        EXPORT_SPEC.web.favicon.sizes.forEach(s => add('web', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`));
    }
    // favicon ico (ä½œä¸ºå•ç‹¬æ–‡ä»¶)
    if (EXPORT_SPEC.web.favicon.formats.includes('ico')) {
        add('web', 'ico', 'favicon.ico', async () => generateIcoFromSizes(EXPORT_SPEC.web.favicon.sizes), 'favicon.ico');
    }
    // apple touch
    EXPORT_SPEC.web.appleTouch.sizes.forEach(s => add('web', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`));
    // pwa
    EXPORT_SPEC.web.pwa.sizes.forEach(s => add('web', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`));

    // chrome extension
    EXPORT_SPEC.chromeExtension.sizes.forEach(s => add('chrome', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`));

    // android
    EXPORT_SPEC.android.mipmap.sizes.forEach(s => {
        add('android', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`);
        if (EXPORT_SPEC.android.mipmap.formats.includes('webp')) add('android', 'webp', sq(s), () => renderSVGToBitmapBlob(s, 'webp'), `icon_${s}.webp`);
    });
    EXPORT_SPEC.android.playStore.sizes.forEach(s => add('android', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`));
    EXPORT_SPEC.android.adaptiveIcon.sizes.forEach(s => add('android', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`));

    // iOS
    EXPORT_SPEC.ios.iphone.sizes.forEach(s => add('ios', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`));
    EXPORT_SPEC.ios.ipad.sizes.forEach(s => add('ios', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`));
    EXPORT_SPEC.ios.appStore.sizes.forEach(s => add('ios', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`));

    // desktop
    if (EXPORT_SPEC.desktop.windows.formats.includes('ico')) {
        add('windows', 'ico', 'icon.ico', async () => generateIcoFromSizes(EXPORT_SPEC.desktop.windows.sizes), 'icon.ico');
    }
    EXPORT_SPEC.desktop.macos.sizes.forEach(s => add('macos', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`));

    // social
    EXPORT_SPEC.social.avatar.sizes.forEach(s => {
        add('social', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`);
        add('social', 'jpg', sq(s), () => renderSVGToBitmapBlob(s, 'jpg'), `icon_${s}.jpg`);
    });
    EXPORT_SPEC.social.share.sizes.forEach(s => {
        add('social', 'png', sq(s), () => renderSVGToBitmapBlob(s, 'png'), `icon_${s}.png`);
        add('social', 'jpg', sq(s), () => renderSVGToBitmapBlob(s, 'jpg'), `icon_${s}.jpg`);
    });
    // 1200x630 ç‰¹æ®Šé¡¹
    const produce1200x630 = async (fmt) => {
        const width = 1200, height = 630; const canvas = document.createElement('canvas'); canvas.width=width; canvas.height=height; const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,width,height);
        const img = new Image(); await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; const svgBlob=new Blob([currentSVG],{type:'image/svg+xml;charset=utf-8'}); img.src=URL.createObjectURL(svgBlob); });
        const size=Math.min(width,height), x=Math.floor((width-size)/2), y=Math.floor((height-size)/2); ctx.drawImage(img,x,y,size,size);
        return await new Promise(r=>canvas.toBlob(b=>r(b), fmt==='jpg'?'image/jpeg':'image/png'));
    };
    add('social', 'png', '1200x630', () => produce1200x630('png'), 'icon_1200x630.png');
    add('social', 'jpg', '1200x630', () => produce1200x630('jpg'), 'icon_1200x630.jpg');

    return items;
}

let exportItems = [];
let selectedItemIds = new Set();

function renderExportTree() {
    const tree = document.getElementById('exportTree');
    if (!tree) return;
    exportItems = buildExportItems();
    selectedItemIds = new Set(exportItems.map(i => i.id)); // é»˜è®¤å…¨é€‰

    const groupOrder = ['web','chrome','android','ios','windows','macos','social'];
    const groupNames = {
        web: getText('exportWeb'), chrome: getText('exportChrome'), android: getText('exportAndroid'),
        ios: getText('exportIOS'), windows: getText('exportWindows'), macos: getText('exportMacOS'), social: getText('exportSocial')
    };
    const icon = (name)=>({ web:'ğŸŒ', chrome:'ğŸ§©', android:'ğŸ¤–', ios:'ğŸ“±', windows:'ğŸªŸ', macos:'ğŸ', social:'ğŸ“£' }[name]||'ğŸ“¦');

    tree.innerHTML = '';

    // å·¥å…·æ¡ï¼šæŒ‰åœºæ™¯æ‰¹é‡é€‰æ‹©
    const toolbar = document.createElement('div');
    toolbar.className = 'group-toolbar';
    const groupTogglesHtml = groupOrder.map(g => `
        <label class="group-toggle" style="margin-right:.75rem;display:inline-flex;align-items:center;gap:.25rem;">
            <input type="checkbox" class="group-toggle-input" data-group="${g}" checked>
            <span>${groupNames[g]}</span>
        </label>
    `).join('');
    const actionsHtml = `
        <button type="button" class="btn btn-small" id="groupSelectAll" style="margin-left:1rem;">${getText('selectAll')||'å…¨é€‰'}</button>
        <button type="button" class="btn btn-small" id="groupClearAll" style="margin-left:.5rem;">${getText('clearAll')||'æ¸…ç©º'}</button>
    `;
    toolbar.innerHTML = `<div style="display:flex;flex-wrap:wrap;align-items:center;gap:.25rem;margin:0 0 .5rem 0;">${groupTogglesHtml}${actionsHtml}</div>`;
    tree.appendChild(toolbar);

    const applyGroupToggle = (group, checked) => {
        const groupItems = exportItems.filter(i => i.group === group);
        groupItems.forEach(it => {
            const cb = document.getElementById(it.id);
            if (cb) { cb.checked = checked; }
            if (checked) selectedItemIds.add(it.id); else selectedItemIds.delete(it.id);
        });
        updateSelectedCount && updateSelectedCount();
    };

    toolbar.querySelectorAll('.group-toggle-input').forEach(input => {
        input.addEventListener('change', (e) => {
            const g = e.target.getAttribute('data-group');
            const checked = e.target.checked;
            applyGroupToggle(g, checked);
            // åŒæ­¥ç»„æ ‡é¢˜å¤é€‰æ¡†
            const headerCb = document.getElementById(`group-${g}`);
            if (headerCb) headerCb.checked = checked;
        });
    });
    const btnAll = toolbar.querySelector('#groupSelectAll');
    if (btnAll) btnAll.addEventListener('click', () => {
        toolbar.querySelectorAll('.group-toggle-input').forEach(i => { i.checked = true; });
        groupOrder.forEach(g => applyGroupToggle(g, true));
        groupOrder.forEach(g => { const headerCb = document.getElementById(`group-${g}`); if (headerCb) headerCb.checked = true; });
    });
    const btnClear = toolbar.querySelector('#groupClearAll');
    if (btnClear) btnClear.addEventListener('click', () => {
        toolbar.querySelectorAll('.group-toggle-input').forEach(i => { i.checked = false; });
        groupOrder.forEach(g => applyGroupToggle(g, false));
        groupOrder.forEach(g => { const headerCb = document.getElementById(`group-${g}`); if (headerCb) headerCb.checked = false; });
    });

    const updateSelectedCount = () => {
        // è‹¥é¡µé¢æœ‰å·²é€‰æ‹©æ•°é‡å±•ç¤ºï¼Œåˆ™æ›´æ–°
        const info = document.getElementById('selectedCount');
        if (info) info.textContent = (getText('selectedSizesCount')||'å·²é€‰æ‹© {n} ä¸ªå°ºå¯¸').replace('{n}', String(selectedItemIds.size));
    };

    groupOrder.forEach(g => {
        const groupItems = exportItems.filter(i => i.group === g);
        if (groupItems.length === 0) return;
        const header = document.createElement('div');
        header.className = 'tree-row';
        const groupId = `group-${g}`;
        header.innerHTML = `
            <label class="tree-item">
                <input type="checkbox" id="${groupId}" checked>
                <span class="tree-icon">${icon(g)}</span>
                <span class="tree-label">${groupNames[g]}</span>
                <span class="tree-summary">${groupItems.length} files</span>
            </label>`;
        tree.appendChild(header);

        header.querySelector('input').addEventListener('change', (e) => {
            const checked = e.target.checked;
            groupItems.forEach(it => {
                const cb = document.getElementById(it.id);
                if (cb) { cb.checked = checked; }
                if (checked) selectedItemIds.add(it.id); else selectedItemIds.delete(it.id);
            });
            // åŒæ­¥å·¥å…·æ¡å¯¹åº”åœºæ™¯å¼€å…³
            const toggle = toolbar.querySelector(`.group-toggle-input[data-group="${g}"]`);
            if (toggle) toggle.checked = checked;
            updateSelectedCount();
        });

        groupItems.forEach(it => {
            const row = document.createElement('div');
            row.className = 'tree-row';
            row.innerHTML = `
                <label class="tree-item" style="padding-left:2rem;">
                    <input type="checkbox" id="${it.id}" checked>
                    <span class="tree-label">${it.fileName}</span>
                    <span class="tree-summary">${it.format.toUpperCase()} Â· ${it.sizeKey}</span>
                </label>`;
            tree.appendChild(row);
            row.querySelector('input').addEventListener('change', (e) => {
                if (e.target.checked) selectedItemIds.add(it.id); else selectedItemIds.delete(it.id);
                updateSelectedCount();
            });
        });
    });
}

async function confirmExportSelection(){
    closeExportModal();
    if (selectedItemIds.size === 0) { showInfo('æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶'); return; }

    const zip = new JSZip();
    const selected = exportItems.filter(i => selectedItemIds.has(i.id));

    try {
        // åºåˆ—åŒ–ç”Ÿæˆï¼Œé¿å…é«˜å†…å­˜å³°å€¼
        for (const it of selected) {
            const blob = await it.producer();
            if (!blob) continue;
            const folderPath = `${it.group}/`;
            zip.file(folderPath + it.fileName, blob);
        }
        // å•ä¸€ zip æ‰“åŒ…ä¸‹è½½
        const content = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'holatiger-icons.zip';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showSuccess('å·²å¼€å§‹ä¸‹è½½æ‰€é€‰æ–‡ä»¶');
    } catch (e) {
        showError(e.message||'å¯¼å‡ºå¤±è´¥');
    }
}

// æ–‡ä»¶é€‰æ‹©ç»Ÿä¸€å…¥å£ï¼Œé¿å…åŒå¼¹çª—
let isFileDialogOpen = false;
function openFileDialogOnce() {
    const fileInputEl = document.getElementById('fileInput');
    if (!fileInputEl) return;
    if (isFileDialogOpen) return;
    isFileDialogOpen = true;
    // é‡ç½® valueï¼Œç¡®ä¿ç›¸åŒæ–‡ä»¶ä¹Ÿå¯è§¦å‘ change
    fileInputEl.value = '';
    fileInputEl.click();
    // å…œåº•ï¼š3s åè‡ªåŠ¨è§£é”
    setTimeout(() => { isFileDialogOpen = false; }, 3000);
}

// æš´éœ²ç»™å…¨å±€ï¼Œä¾¿äº HTML inline äº‹ä»¶è°ƒç”¨
window.openExportModal = openExportModal;
window.closeExportModal = closeExportModal;
window.confirmExportSelection = confirmExportSelection;
window.toggleExportSelection = toggleExportSelection;
window.openFileDialogOnce = openFileDialogOnce;

function openExportModal() {
    const modal = document.getElementById('exportModal');
    if (!modal) return;
    modal.classList.remove('hidden');
    // æ‰“å¼€æ—¶åˆ·æ–°å¯¼å‡ºæ ‘
    try { renderExportTree(); } catch (e) { /* å¿½ç•¥æ¸²æŸ“å¼‚å¸¸ä»¥å…é˜»æ–­æ‰“å¼€ */ }
}

function closeExportModal() {
    const modal = document.getElementById('exportModal');
    if (!modal) return;
    modal.classList.add('hidden');
}

function toggleExportSelection(selectAll) {
    const tree = document.getElementById('exportTree');
    if (!tree) return;
    const inputs = tree.querySelectorAll('input[type="checkbox"]');
    inputs.forEach(cb => {
        cb.checked = !!selectAll;
        const id = cb.id;
        if (!id) return;
        if (cb.checked) {
            if (typeof selectedItemIds !== 'undefined' && selectedItemIds instanceof Set) selectedItemIds.add(id);
        } else {
            if (typeof selectedItemIds !== 'undefined' && selectedItemIds instanceof Set) selectedItemIds.delete(id);
        }
    });
}